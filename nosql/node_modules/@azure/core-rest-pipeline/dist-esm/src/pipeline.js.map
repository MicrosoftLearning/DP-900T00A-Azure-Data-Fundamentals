{"version":3,"file":"pipeline.js","sourceRoot":"","sources":["../../src/pipeline.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  PipelineRequest,\n  PipelineResponse,\n  HttpClient,\n  SendRequest,\n  ProxySettings\n} from \"./interfaces\";\nimport { LogPolicyOptions, logPolicy } from \"./policies/logPolicy\";\nimport { UserAgentPolicyOptions, userAgentPolicy } from \"./policies/userAgentPolicy\";\nimport { RedirectPolicyOptions, redirectPolicy } from \"./policies/redirectPolicy\";\nimport {\n  ExponentialRetryPolicyOptions,\n  exponentialRetryPolicy\n} from \"./policies/exponentialRetryPolicy\";\nimport { tracingPolicy } from \"./policies/tracingPolicy\";\nimport { setClientRequestIdPolicy } from \"./policies/setClientRequestIdPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { decompressResponsePolicy } from \"./policies/decompressResponsePolicy\";\nimport { proxyPolicy } from \"./policies/proxyPolicy\";\nimport { isNode } from \"./util/helpers\";\nimport { formDataPolicy } from \"./policies/formDataPolicy\";\n\n/**\n * Policies are executed in phases.\n * The execution order is:\n * 1. Serialize Phase\n * 2. Policies not in a phase\n * 3. Deserialize Phase\n * 4. Retry Phase\n */\nexport type PipelinePhase = \"Deserialize\" | \"Serialize\" | \"Retry\";\n\nconst ValidPhaseNames = new Set<PipelinePhase>([\"Deserialize\", \"Serialize\", \"Retry\"]);\n\n/**\n * Options when adding a policy to the pipeline.\n * Used to express dependencies on other policies.\n */\nexport interface AddPolicyOptions {\n  /**\n   * Policies that this policy must come before.\n   */\n  beforePolicies?: string[];\n  /**\n   * Policies that this policy must come after.\n   */\n  afterPolicies?: string[];\n  /**\n   * The phase that this policy must come after.\n   */\n  afterPhase?: PipelinePhase;\n  /**\n   * The phase this policy belongs to.\n   */\n  phase?: PipelinePhase;\n}\n\n/**\n * A pipeline policy manipulates a request as it travels through the pipeline.\n * It is conceptually a middleware that is allowed to modify the request before\n * it is made as well as the response when it is received.\n */\nexport interface PipelinePolicy {\n  /**\n   * The policy name. Must be a unique string in the pipeline.\n   */\n  name: string;\n  /**\n   * The main method to implement that manipulates a request/response.\n   * @param request - The request being performed.\n   * @param next - The next policy in the pipeline. Must be called to continue the pipeline.\n   */\n  sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse>;\n}\n\n/**\n * Represents a pipeline for making a HTTP request to a URL.\n * Pipelines can have multiple policies to manage manipulating each request\n * before and after it is made to the server.\n */\nexport interface Pipeline {\n  /**\n   * Add a new policy to the pipeline.\n   * @param policy - A policy that manipulates a request.\n   * @param options - A set of options for when the policy should run.\n   */\n  addPolicy(policy: PipelinePolicy, options?: AddPolicyOptions): void;\n  /**\n   * Remove a policy from the pipeline.\n   * @param options - Options that let you specify which policies to remove.\n   */\n  removePolicy(options: { name?: string; phase?: PipelinePhase }): PipelinePolicy[];\n  /**\n   * Uses the pipeline to make a HTTP request.\n   * @param httpClient - The HttpClient that actually performs the request.\n   * @param request - The request to be made.\n   */\n  sendRequest(httpClient: HttpClient, request: PipelineRequest): Promise<PipelineResponse>;\n  /**\n   * Returns the current set of policies in the pipeline in the order in which\n   * they will be applied to the request. Later in the list is closer to when\n   * the request is performed.\n   */\n  getOrderedPolicies(): PipelinePolicy[];\n  /**\n   * Duplicates this pipeline to allow for modifying an existing one without mutating it.\n   */\n  clone(): Pipeline;\n}\n\ninterface PipelineDescriptor {\n  policy: PipelinePolicy;\n  options: AddPolicyOptions;\n}\n\ninterface PolicyGraphNode {\n  policy: PipelinePolicy;\n  dependsOn: Set<PolicyGraphNode>;\n  dependants: Set<PolicyGraphNode>;\n  afterPhase?: Set<PolicyGraphNode>;\n}\n\n/**\n * A private implementation of Pipeline.\n * Do not export this class from the package.\n * @internal\n */\nclass HttpPipeline implements Pipeline {\n  private _policies: PipelineDescriptor[] = [];\n  private _orderedPolicies?: PipelinePolicy[];\n\n  private constructor(policies: PipelineDescriptor[] = []) {\n    this._policies = policies;\n    this._orderedPolicies = undefined;\n  }\n\n  public addPolicy(policy: PipelinePolicy, options: AddPolicyOptions = {}): void {\n    if (options.phase && options.afterPhase) {\n      throw new Error(\"Policies inside a phase cannot specify afterPhase.\");\n    }\n    if (options.phase && !ValidPhaseNames.has(options.phase)) {\n      throw new Error(`Invalid phase name: ${options.phase}`);\n    }\n    if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {\n      throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);\n    }\n    this._policies.push({\n      policy,\n      options\n    });\n    this._orderedPolicies = undefined;\n  }\n\n  public removePolicy(options: { name?: string; phase?: string }): PipelinePolicy[] {\n    const removedPolicies: PipelinePolicy[] = [];\n\n    this._policies = this._policies.filter((policyDescriptor) => {\n      if (\n        (options.name && policyDescriptor.policy.name === options.name) ||\n        (options.phase && policyDescriptor.options.phase === options.phase)\n      ) {\n        removedPolicies.push(policyDescriptor.policy);\n        return false;\n      } else {\n        return true;\n      }\n    });\n    this._orderedPolicies = undefined;\n\n    return removedPolicies;\n  }\n\n  public sendRequest(httpClient: HttpClient, request: PipelineRequest): Promise<PipelineResponse> {\n    const policies = this.getOrderedPolicies();\n\n    const pipeline = policies.reduceRight<SendRequest>(\n      (next, policy) => {\n        return (req: PipelineRequest) => {\n          return policy.sendRequest(req, next);\n        };\n      },\n      (req: PipelineRequest) => httpClient.sendRequest(req)\n    );\n\n    return pipeline(request);\n  }\n\n  public getOrderedPolicies(): PipelinePolicy[] {\n    if (!this._orderedPolicies) {\n      this._orderedPolicies = this.orderPolicies();\n    }\n    return this._orderedPolicies;\n  }\n\n  public clone(): Pipeline {\n    return new HttpPipeline(this._policies);\n  }\n\n  public static create(): Pipeline {\n    return new HttpPipeline();\n  }\n\n  private orderPolicies(): PipelinePolicy[] {\n    /**\n     * The goal of this method is to reliably order pipeline policies\n     * based on their declared requirements when they were added.\n     *\n     * Order is first determined by phase:\n     *\n     * 1. Serialize Phase\n     * 2. Policies not in a phase\n     * 3. Deserialize Phase\n     * 4. Retry Phase\n     *\n     * Within each phase, policies are executed in the order\n     * they were added unless they were specified to execute\n     * before/after other policies or after a particular phase.\n     *\n     * To determine the final order, we will walk the policy list\n     * in phase order multiple times until all dependencies are\n     * satisfied.\n     *\n     * `afterPolicies` are the set of policies that must be\n     * executed before a given policy. This requirement is\n     * considered satisfied when each of the listed policies\n     * have been scheduled.\n     *\n     * `beforePolicies` are the set of policies that must be\n     * executed after a given policy. Since this dependency\n     * can be expressed by converting it into a equivalent\n     * `afterPolicies` declarations, they are normalized\n     * into that form for simplicity.\n     *\n     * An `afterPhase` dependency is considered satisfied when all\n     * policies in that phase have scheduled.\n     *\n     */\n    const result: PipelinePolicy[] = [];\n\n    // Track all policies we know about.\n    const policyMap: Map<string, PolicyGraphNode> = new Map<string, PolicyGraphNode>();\n\n    // Track policies for each phase.\n    const serializePhase = new Set<PolicyGraphNode>();\n    const noPhase = new Set<PolicyGraphNode>();\n    const deserializePhase = new Set<PolicyGraphNode>();\n    const retryPhase = new Set<PolicyGraphNode>();\n\n    // a list of phases in order\n    const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase];\n\n    // Small helper function to map phase name to each Set bucket.\n    function getPhase(phase: PipelinePhase | undefined): Set<PolicyGraphNode> {\n      if (phase === \"Retry\") {\n        return retryPhase;\n      } else if (phase === \"Serialize\") {\n        return serializePhase;\n      } else if (phase === \"Deserialize\") {\n        return deserializePhase;\n      } else {\n        return noPhase;\n      }\n    }\n\n    // First walk each policy and create a node to track metadata.\n    for (const descriptor of this._policies) {\n      const policy = descriptor.policy;\n      const options = descriptor.options;\n      const policyName = policy.name;\n      if (policyMap.has(policyName)) {\n        throw new Error(\"Duplicate policy names not allowed in pipeline\");\n      }\n      const node: PolicyGraphNode = {\n        policy,\n        dependsOn: new Set<PolicyGraphNode>(),\n        dependants: new Set<PolicyGraphNode>()\n      };\n      if (options.afterPhase) {\n        node.afterPhase = getPhase(options.afterPhase);\n      }\n      policyMap.set(policyName, node);\n      const phase = getPhase(options.phase);\n      phase.add(node);\n    }\n\n    // Now that each policy has a node, connect dependency references.\n    for (const descriptor of this._policies) {\n      const { policy, options } = descriptor;\n      const policyName = policy.name;\n      const node = policyMap.get(policyName);\n      if (!node) {\n        throw new Error(`Missing node for policy ${policyName}`);\n      }\n\n      if (options.afterPolicies) {\n        for (const afterPolicyName of options.afterPolicies) {\n          const afterNode = policyMap.get(afterPolicyName);\n          if (afterNode) {\n            // Linking in both directions helps later\n            // when we want to notify dependants.\n            node.dependsOn.add(afterNode);\n            afterNode.dependants.add(node);\n          }\n        }\n      }\n      if (options.beforePolicies) {\n        for (const beforePolicyName of options.beforePolicies) {\n          const beforeNode = policyMap.get(beforePolicyName);\n          if (beforeNode) {\n            // To execute before another node, make it\n            // depend on the current node.\n            beforeNode.dependsOn.add(node);\n            node.dependants.add(beforeNode);\n          }\n        }\n      }\n    }\n\n    function walkPhase(phase: Set<PolicyGraphNode>): void {\n      // Sets iterate in insertion order\n      for (const node of phase) {\n        if (node.afterPhase && node.afterPhase.size) {\n          // If this node is waiting on a phase to complete,\n          // we need to skip it for now.\n          continue;\n        }\n        if (node.dependsOn.size === 0) {\n          // If there's nothing else we're waiting for, we can\n          // add this policy to the result list.\n          result.push(node.policy);\n          // Notify anything that depends on this policy that\n          // the policy has been scheduled.\n          for (const dependant of node.dependants) {\n            dependant.dependsOn.delete(node);\n          }\n          policyMap.delete(node.policy.name);\n          phase.delete(node);\n        }\n      }\n    }\n\n    function walkPhases(): void {\n      let noPhaseRan = false;\n\n      for (const phase of orderedPhases) {\n        walkPhase(phase);\n        if (phase === noPhase) {\n          noPhaseRan = true;\n        }\n        // if the phase isn't complete\n        if (phase.size > 0 && phase !== noPhase) {\n          if (noPhaseRan === false) {\n            // Try running noPhase to see if that unblocks this phase next tick.\n            // This can happen if a phase that happens before noPhase\n            // is waiting on a noPhase policy to complete.\n            walkPhase(noPhase);\n          }\n          // Don't proceed to the next phase until this phase finishes.\n          return;\n        }\n      }\n    }\n\n    // Iterate until we've put every node in the result list.\n    while (policyMap.size > 0) {\n      const initialResultLength = result.length;\n      // Keep walking each phase in order until we can order every node.\n      walkPhases();\n      // The result list *should* get at least one larger each time.\n      // Otherwise, we're going to loop forever.\n      if (result.length <= initialResultLength) {\n        throw new Error(\"Cannot satisfy policy dependencies due to requirements cycle.\");\n      }\n    }\n\n    return result;\n  }\n}\n\n/**\n * Creates a totally empty pipeline.\n * Useful for testing or creating a custom one.\n */\nexport function createEmptyPipeline(): Pipeline {\n  return HttpPipeline.create();\n}\n\n/**\n * Defines options that are used to configure the HTTP pipeline for\n * an SDK client.\n */\nexport interface PipelineOptions {\n  /**\n   * Options that control how to retry failed requests.\n   */\n  retryOptions?: ExponentialRetryPolicyOptions;\n\n  /**\n   * Options to configure a proxy for outgoing requests.\n   */\n  proxyOptions?: ProxySettings;\n\n  /**\n   * Options for how redirect responses are handled.\n   */\n  redirectOptions?: RedirectPolicyOptions;\n\n  /**\n   * Options for adding user agent details to outgoing requests.\n   */\n  userAgentOptions?: UserAgentPolicyOptions;\n}\n\n/**\n * Defines options that are used to configure internal options of\n * the HTTP pipeline for an SDK client.\n */\nexport interface InternalPipelineOptions extends PipelineOptions {\n  /**\n   * Options to configure request/response logging.\n   */\n  loggingOptions?: LogPolicyOptions;\n}\n\n/**\n * Create a new pipeline with a default set of customizable policies.\n * @param options - Options to configure a custom pipeline.\n */\nexport function createPipelineFromOptions(options: InternalPipelineOptions): Pipeline {\n  const pipeline = HttpPipeline.create();\n\n  if (isNode) {\n    pipeline.addPolicy(proxyPolicy(options.proxyOptions));\n    pipeline.addPolicy(decompressResponsePolicy());\n  }\n\n  pipeline.addPolicy(formDataPolicy());\n  pipeline.addPolicy(tracingPolicy(options.userAgentOptions));\n  pipeline.addPolicy(userAgentPolicy(options.userAgentOptions));\n  pipeline.addPolicy(setClientRequestIdPolicy());\n  pipeline.addPolicy(throttlingRetryPolicy(), { phase: \"Retry\" });\n  pipeline.addPolicy(systemErrorRetryPolicy(options.retryOptions), { phase: \"Retry\" });\n  pipeline.addPolicy(exponentialRetryPolicy(options.retryOptions), { phase: \"Retry\" });\n  pipeline.addPolicy(redirectPolicy(options.redirectOptions), { afterPhase: \"Retry\" });\n  pipeline.addPolicy(logPolicy(options.loggingOptions), { afterPhase: \"Retry\" });\n\n  return pipeline;\n}\n"]}