{"version":3,"file":"index.js","sources":["../src/log.ts","../src/util/helpers.ts","../src/util/sanitizer.ts","../src/policies/logPolicy.ts","../src/util/userAgentPlatform.ts","../src/constants.ts","../src/util/userAgent.ts","../src/policies/userAgentPolicy.ts","../src/policies/redirectPolicy.ts","../src/util/inspect.ts","../src/restError.ts","../src/policies/exponentialRetryPolicy.ts","../src/policies/tracingPolicy.ts","../src/policies/setClientRequestIdPolicy.ts","../src/policies/throttlingRetryPolicy.ts","../src/policies/systemErrorRetryPolicy.ts","../src/policies/decompressResponsePolicy.ts","../src/policies/proxyPolicy.ts","../src/policies/formDataPolicy.ts","../src/pipeline.ts","../src/httpHeaders.ts","../src/nodeHttpClient.ts","../src/defaultHttpClient.ts","../src/util/uuid.ts","../src/pipelineRequest.ts","../src/util/tokenCycler.ts","../src/policies/bearerTokenAuthenticationPolicy.ts","../src/policies/ndJsonPolicy.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createClientLogger } from \"@azure/logger\";\nexport const logger = createClientLogger(\"core-rest-pipeline\");\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * A constant that indicates whether the environment the code is running is Node.JS.\n * @internal\n */\nexport const isNode =\n  typeof process !== \"undefined\" && Boolean(process.version) && Boolean(process.versions?.node);\n\n/**\n * A wrapper for setTimeout that resolves a promise after t milliseconds.\n * @internal\n * @param t - The number of milliseconds to be delayed.\n * @param value - The value to be resolved with after a timeout of t milliseconds.\n * @returns Resolved promise\n */\nexport function delay<T>(t: number, value?: T): Promise<T | void> {\n  return new Promise((resolve) => setTimeout(() => resolve(value), t));\n}\n\n/**\n * Returns a random integer value between a lower and upper bound,\n * inclusive of both bounds.\n * Note that this uses Math.random and isn't secure. If you need to use\n * this for any kind of security purpose, find a better source of random.\n * @param min - The smallest integer value allowed.\n * @param max - The largest integer value allowed.\n * @internal\n */\nexport function getRandomIntegerInclusive(min: number, max: number): number {\n  // Make sure inputs are integers.\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  // Pick a random offset from zero to the size of the range.\n  // Since Math.random() can never return 1, we have to make the range one larger\n  // in order to be inclusive of the maximum value after we take the floor.\n  const offset = Math.floor(Math.random() * (max - min + 1));\n  return offset + min;\n}\n\n/**\n * @internal\n */\nexport type UnknownObject = { [s: string]: unknown };\n\n/**\n * @internal\n * @returns true when input is an object type that is not null, Array, RegExp, or Date.\n */\nexport function isObject(input: unknown): input is UnknownObject {\n  return (\n    typeof input === \"object\" &&\n    input !== null &&\n    !Array.isArray(input) &&\n    !(input instanceof RegExp) &&\n    !(input instanceof Date)\n  );\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { isObject, UnknownObject } from \"./helpers\";\nimport { URL } from \"./url\";\n\n/**\n * @internal\n */\nexport interface SanitizerOptions {\n  /**\n   * Header names whose values will be logged when logging is enabled.\n   * Defaults include a list of well-known safe headers. Any headers\n   * specified in this field will be added to that list.  Any other values will\n   * be written to logs as \"REDACTED\".\n   */\n  additionalAllowedHeaderNames?: string[];\n\n  /**\n   * Query string names whose values will be logged when logging is enabled. By default no\n   * query string values are logged.\n   */\n  additionalAllowedQueryParameters?: string[];\n}\n\nconst RedactedString = \"REDACTED\";\n\nconst defaultAllowedHeaderNames = [\n  \"x-ms-client-request-id\",\n  \"x-ms-return-client-request-id\",\n  \"x-ms-useragent\",\n  \"x-ms-correlation-request-id\",\n  \"x-ms-request-id\",\n  \"client-request-id\",\n  \"ms-cv\",\n  \"return-client-request-id\",\n  \"traceparent\",\n\n  \"Access-Control-Allow-Credentials\",\n  \"Access-Control-Allow-Headers\",\n  \"Access-Control-Allow-Methods\",\n  \"Access-Control-Allow-Origin\",\n  \"Access-Control-Expose-Headers\",\n  \"Access-Control-Max-Age\",\n  \"Access-Control-Request-Headers\",\n  \"Access-Control-Request-Method\",\n  \"Origin\",\n\n  \"Accept\",\n  \"Accept-Encoding\",\n  \"Cache-Control\",\n  \"Connection\",\n  \"Content-Length\",\n  \"Content-Type\",\n  \"Date\",\n  \"ETag\",\n  \"Expires\",\n  \"If-Match\",\n  \"If-Modified-Since\",\n  \"If-None-Match\",\n  \"If-Unmodified-Since\",\n  \"Last-Modified\",\n  \"Pragma\",\n  \"Request-Id\",\n  \"Retry-After\",\n  \"Server\",\n  \"Transfer-Encoding\",\n  \"User-Agent\"\n];\n\nconst defaultAllowedQueryParameters: string[] = [\"api-version\"];\n\n/**\n * @internal\n */\nexport class Sanitizer {\n  private allowedHeaderNames: Set<string>;\n  private allowedQueryParameters: Set<string>;\n\n  constructor({\n    additionalAllowedHeaderNames: allowedHeaderNames = [],\n    additionalAllowedQueryParameters: allowedQueryParameters = []\n  }: SanitizerOptions = {}) {\n    allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);\n    allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);\n\n    this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));\n    this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));\n  }\n\n  public sanitize(obj: unknown): string {\n    const seen = new Set<unknown>();\n    return JSON.stringify(\n      obj,\n      (key: string, value: unknown) => {\n        // Ensure Errors include their interesting non-enumerable members\n        if (value instanceof Error) {\n          return {\n            ...value,\n            name: value.name,\n            message: value.message\n          };\n        }\n\n        if (key === \"headers\") {\n          return this.sanitizeHeaders(value as UnknownObject);\n        } else if (key === \"url\") {\n          return this.sanitizeUrl(value as string);\n        } else if (key === \"query\") {\n          return this.sanitizeQuery(value as UnknownObject);\n        } else if (key === \"body\") {\n          // Don't log the request body\n          return undefined;\n        } else if (key === \"response\") {\n          // Don't log response again\n          return undefined;\n        } else if (key === \"operationSpec\") {\n          // When using sendOperationRequest, the request carries a massive\n          // field with the autorest spec. No need to log it.\n          return undefined;\n        } else if (Array.isArray(value) || isObject(value)) {\n          if (seen.has(value)) {\n            return \"[Circular]\";\n          }\n          seen.add(value);\n        }\n\n        return value;\n      },\n      2\n    );\n  }\n\n  private sanitizeHeaders(obj: UnknownObject): UnknownObject {\n    const sanitized: UnknownObject = {};\n    for (const key of Object.keys(obj)) {\n      if (this.allowedHeaderNames.has(key.toLowerCase())) {\n        sanitized[key] = obj[key];\n      } else {\n        sanitized[key] = RedactedString;\n      }\n    }\n    return sanitized;\n  }\n\n  private sanitizeQuery(value: UnknownObject): UnknownObject {\n    if (typeof value !== \"object\" || value === null) {\n      return value;\n    }\n\n    const sanitized: UnknownObject = {};\n\n    for (const k of Object.keys(value)) {\n      if (this.allowedQueryParameters.has(k.toLowerCase())) {\n        sanitized[k] = value[k];\n      } else {\n        sanitized[k] = RedactedString;\n      }\n    }\n\n    return sanitized;\n  }\n\n  private sanitizeUrl(value: string): string {\n    if (typeof value !== \"string\" || value === null) {\n      return value;\n    }\n\n    const url = new URL(value);\n\n    if (!url.search) {\n      return value;\n    }\n\n    for (const [key] of url.searchParams) {\n      if (!this.allowedQueryParameters.has(key.toLowerCase())) {\n        url.searchParams.set(key, RedactedString);\n      }\n    }\n\n    return url.toString();\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Debugger } from \"@azure/logger\";\nimport { PipelineResponse, PipelineRequest, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\nimport { logger as coreLogger } from \"../log\";\nimport { Sanitizer } from \"../util/sanitizer\";\n\n/**\n * The programmatic identifier of the logPolicy.\n */\nexport const logPolicyName = \"logPolicy\";\n\n/**\n * Options to configure the logPolicy.\n */\nexport interface LogPolicyOptions {\n  /**\n   * Header names whose values will be logged when logging is enabled.\n   * Defaults include a list of well-known safe headers. Any headers\n   * specified in this field will be added to that list.  Any other values will\n   * be written to logs as \"REDACTED\".\n   */\n  additionalAllowedHeaderNames?: string[];\n\n  /**\n   * Query string names whose values will be logged when logging is enabled. By default no\n   * query string values are logged.\n   */\n  additionalAllowedQueryParameters?: string[];\n\n  /**\n   * The log function to use for writing pipeline logs.\n   * Defaults to core-http's built-in logger.\n   * Compatible with the `debug` library.\n   */\n  logger?: Debugger;\n}\n\n/**\n * A policy that logs all requests and responses.\n * @param options - Options to configure logPolicy.\n */\nexport function logPolicy(options: LogPolicyOptions = {}): PipelinePolicy {\n  const logger = options.logger ?? coreLogger.info;\n  const sanitizer = new Sanitizer({\n    additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,\n    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters\n  });\n  return {\n    name: logPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!logger.enabled) {\n        return next(request);\n      }\n\n      logger(`Request: ${sanitizer.sanitize(request)}`);\n\n      const response = await next(request);\n\n      logger(`Response status code: ${response.status}`);\n      logger(`Headers: ${sanitizer.sanitize(response.headers)}`);\n\n      return response;\n    }\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as os from \"os\";\n\n/**\n * @internal\n */\nexport function getHeaderName(): string {\n  return \"User-Agent\";\n}\n\n/**\n * @internal\n */\nexport function setPlatformSpecificData(map: Map<string, string>): void {\n  map.set(\"Node\", process.version);\n  map.set(\"OS\", `(${os.arch()}-${os.type()}-${os.release()})`);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nexport const SDK_VERSION: string = \"1.1.2\";\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { setPlatformSpecificData, getHeaderName } from \"./userAgentPlatform\";\nimport { SDK_VERSION } from \"../constants\";\n\nfunction getUserAgentString(telemetryInfo: Map<string, string>): string {\n  const parts: string[] = [];\n  for (const [key, value] of telemetryInfo) {\n    const token = value ? `${key}/${value}` : key;\n    parts.push(token);\n  }\n  return parts.join(\" \");\n}\n\n/**\n * @internal\n */\nexport function getUserAgentHeaderName(): string {\n  return getHeaderName();\n}\n\n/**\n * @internal\n */\nexport function getUserAgentValue(prefix?: string): string {\n  const runtimeInfo = new Map<string, string>();\n  runtimeInfo.set(\"core-rest-pipeline\", SDK_VERSION);\n  setPlatformSpecificData(runtimeInfo);\n  const defaultAgent = getUserAgentString(runtimeInfo);\n  const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;\n  return userAgentValue;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PipelineResponse, PipelineRequest, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\nimport { getUserAgentValue, getUserAgentHeaderName } from \"../util/userAgent\";\n\nconst UserAgentHeaderName = getUserAgentHeaderName();\n\n/**\n * The programmatic identifier of the userAgentPolicy.\n */\nexport const userAgentPolicyName = \"userAgentPolicy\";\n\n/**\n * Options for adding user agent details to outgoing requests.\n */\nexport interface UserAgentPolicyOptions {\n  /**\n   * String prefix to add to the user agent for outgoing requests.\n   * Defaults to an empty string.\n   */\n  userAgentPrefix?: string;\n}\n\n/**\n * A policy that sets the User-Agent header (or equivalent) to reflect\n * the library version.\n * @param options - Options to customize the user agent value.\n */\nexport function userAgentPolicy(options: UserAgentPolicyOptions = {}): PipelinePolicy {\n  const userAgentValue = getUserAgentValue(options.userAgentPrefix);\n  return {\n    name: userAgentPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.headers.has(UserAgentHeaderName)) {\n        request.headers.set(UserAgentHeaderName, userAgentValue);\n      }\n      return next(request);\n    }\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PipelineResponse, PipelineRequest, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\nimport { URL } from \"../util/url\";\n\n/**\n * The programmatic identifier of the redirectPolicy.\n */\nexport const redirectPolicyName = \"redirectPolicy\";\n\n/**\n * Methods that are allowed to follow redirects 301 and 302\n */\nconst allowedRedirect = [\"GET\", \"HEAD\"];\n\n/**\n * Options for how redirect responses are handled.\n */\nexport interface RedirectPolicyOptions {\n  /**\n   * The maximum number of times the redirect URL will be tried before\n   * failing.  Defaults to 20.\n   */\n  maxRetries?: number;\n}\n\n/**\n * A policy to follow Location headers from the server in order\n * to support server-side redirection.\n * @param options - Options to control policy behavior.\n */\nexport function redirectPolicy(options: RedirectPolicyOptions = {}): PipelinePolicy {\n  const { maxRetries = 20 } = options;\n  return {\n    name: redirectPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      const response = await next(request);\n      return handleRedirect(next, response, maxRetries);\n    }\n  };\n}\n\nasync function handleRedirect(\n  next: SendRequest,\n  response: PipelineResponse,\n  maxRetries: number,\n  currentRetries: number = 0\n): Promise<PipelineResponse> {\n  const { request, status, headers } = response;\n  const locationHeader = headers.get(\"location\");\n  if (\n    locationHeader &&\n    (status === 300 ||\n      (status === 301 && allowedRedirect.includes(request.method)) ||\n      (status === 302 && allowedRedirect.includes(request.method)) ||\n      (status === 303 && request.method === \"POST\") ||\n      status === 307) &&\n    currentRetries < maxRetries\n  ) {\n    const url = new URL(locationHeader, request.url);\n    request.url = url.toString();\n\n    // POST request with Status code 303 should be converted into a\n    // redirected GET request if the redirect url is present in the location header\n    if (status === 303) {\n      request.method = \"GET\";\n      request.headers.delete(\"Content-Length\");\n      delete request.body;\n    }\n\n    const res = await next(request);\n    return handleRedirect(next, res, maxRetries, currentRetries + 1);\n  }\n\n  return response;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { inspect } from \"util\";\n\nexport const custom = inspect.custom;\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PipelineResponse, PipelineRequest } from \"./interfaces\";\nimport { custom } from \"./util/inspect\";\nimport { Sanitizer } from \"./util/sanitizer\";\n\nconst errorSanitizer = new Sanitizer();\n\n/**\n * The options supported by RestError.\n */\nexport interface RestErrorOptions {\n  /**\n   * The code of the error itself (use statics on RestError if possible.)\n   */\n  code?: string;\n  /**\n   * The HTTP status code of the request (if applicable.)\n   */\n  statusCode?: number;\n  /**\n   * The request that was made.\n   */\n  request?: PipelineRequest;\n  /**\n   * The response received (if any.)\n   */\n  response?: PipelineResponse;\n}\n\n/**\n * A custom error type for failed pipeline requests.\n */\nexport class RestError extends Error {\n  /**\n   * Something went wrong when making the request.\n   * This means the actual request failed for some reason,\n   * such as a DNS issue or the connection being lost.\n   */\n  static readonly REQUEST_SEND_ERROR: string = \"REQUEST_SEND_ERROR\";\n  /**\n   * This means that parsing the response from the server failed.\n   * It may have been malformed.\n   */\n  static readonly PARSE_ERROR: string = \"PARSE_ERROR\";\n\n  /**\n   * The code of the error itself (use statics on RestError if possible.)\n   */\n  public code?: string;\n  /**\n   * The HTTP status code of the request (if applicable.)\n   */\n  public statusCode?: number;\n  /**\n   * The request that was made.\n   */\n  public request?: PipelineRequest;\n  /**\n   * The response received (if any.)\n   */\n  public response?: PipelineResponse;\n  /**\n   * Bonus property set by the throw site.\n   */\n  public details?: unknown;\n\n  constructor(message: string, options: RestErrorOptions = {}) {\n    super(message);\n    this.name = \"RestError\";\n    this.code = options.code;\n    this.statusCode = options.statusCode;\n    this.request = options.request;\n    this.response = options.response;\n\n    Object.setPrototypeOf(this, RestError.prototype);\n  }\n\n  /**\n   * Logging method for util.inspect in Node\n   */\n  [custom](): string {\n    return `RestError: ${this.message} \\n ${errorSanitizer.sanitize(this)}`;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PipelineResponse, PipelineRequest, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\nimport { logger } from \"../log\";\nimport { delay, getRandomIntegerInclusive } from \"../util/helpers\";\nimport { RestError } from \"../restError\";\n\n/**\n * The programmatic identifier of the exponentialRetryPolicy.\n */\nexport const exponentialRetryPolicyName = \"exponentialRetryPolicy\";\n\nconst DEFAULT_CLIENT_RETRY_COUNT = 10;\n// intervals are in ms\nconst DEFAULT_CLIENT_RETRY_INTERVAL = 1000;\nconst DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 64;\n\ninterface RetryData {\n  retryCount: number;\n  retryInterval: number;\n  error?: RetryError;\n}\n\ninterface RetryError extends Error {\n  message: string;\n  code?: string;\n  innerError?: RetryError;\n}\n\n/**\n * Options that control how to retry failed requests.\n */\nexport interface ExponentialRetryPolicyOptions {\n  /**\n   * The maximum number of retry attempts.  Defaults to 10.\n   */\n  maxRetries?: number;\n\n  /**\n   * The amount of delay in milliseconds between retry attempts. Defaults to 1000\n   * (1 second.) The delay increases exponentially with each retry up to a maximum\n   * specified by maxRetryDelayInMs.\n   */\n  retryDelayInMs?: number;\n\n  /**\n   * The maximum delay in milliseconds allowed before retrying an operation. Defaults\n   * to 64000 (64 seconds).\n   */\n  maxRetryDelayInMs?: number;\n}\n\n/**\n * A policy that attempts to retry requests while introducing an exponentially increasing delay.\n * @param options - Options that configure retry logic.\n */\nexport function exponentialRetryPolicy(\n  options: ExponentialRetryPolicyOptions = {}\n): PipelinePolicy {\n  const retryCount = options.maxRetries ?? DEFAULT_CLIENT_RETRY_COUNT;\n  const retryInterval = options.retryDelayInMs ?? DEFAULT_CLIENT_RETRY_INTERVAL;\n  const maxRetryInterval = options.maxRetryDelayInMs ?? DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n\n  /**\n   * Determines if the operation should be retried and how long to wait until the next retry.\n   *\n   * @param statusCode - The HTTP status code.\n   * @param retryData -  The retry data.\n   * @returns True if the operation qualifies for a retry; false otherwise.\n   */\n  function shouldRetry(response: PipelineResponse | undefined, retryData: RetryData): boolean {\n    const statusCode = response?.status;\n    if (statusCode === 503 && response?.headers.get(\"Retry-After\")) {\n      return false;\n    }\n\n    if (\n      statusCode === undefined ||\n      (statusCode < 500 && statusCode !== 408) ||\n      statusCode === 501 ||\n      statusCode === 505\n    ) {\n      return false;\n    }\n\n    const currentCount = retryData && retryData.retryCount;\n\n    return currentCount < retryCount;\n  }\n\n  /**\n   * Updates the retry data for the next attempt.\n   *\n   * @param retryData -  The retry data.\n   * @param err - The operation's error, if any.\n   */\n  function updateRetryData(retryData: RetryData, err?: RetryError): RetryData {\n    if (err) {\n      if (retryData.error) {\n        err.innerError = retryData.error;\n      }\n\n      retryData.error = err;\n    }\n\n    // Adjust retry count\n    retryData.retryCount++;\n\n    // Exponentially increase the delay each time\n    const exponentialDelay = retryInterval * Math.pow(2, retryData.retryCount);\n    // Don't let the delay exceed the maximum\n    const clampedExponentialDelay = Math.min(maxRetryInterval, exponentialDelay);\n    // Allow the final value to have some \"jitter\" (within 50% of the delay size) so\n    // that retries across multiple clients don't occur simultaneously.\n    const delayWithJitter =\n      clampedExponentialDelay / 2 + getRandomIntegerInclusive(0, clampedExponentialDelay / 2);\n\n    retryData.retryInterval = delayWithJitter;\n\n    return retryData;\n  }\n\n  async function retry(\n    next: SendRequest,\n    retryData: RetryData,\n    request: PipelineRequest,\n    response?: PipelineResponse,\n    requestError?: RetryError\n  ): Promise<PipelineResponse> {\n    retryData = updateRetryData(retryData, requestError);\n    const isAborted = request.abortSignal?.aborted;\n    if (!isAborted && shouldRetry(response, retryData)) {\n      logger.info(`Retrying request in ${retryData.retryInterval}`);\n      try {\n        await delay(retryData.retryInterval);\n        const res = await next(request);\n        return retry(next, retryData, request, res);\n      } catch (e) {\n        return retry(next, retryData, request, response, e);\n      }\n    } else if (isAborted || requestError || !response) {\n      // If the operation failed in the end, return all errors instead of just the last one\n      const err =\n        retryData.error ||\n        new RestError(\"Failed to send the request.\", {\n          code: RestError.REQUEST_SEND_ERROR,\n          statusCode: response?.status,\n          request: response?.request,\n          response\n        });\n      throw err;\n    } else {\n      return response;\n    }\n  }\n\n  return {\n    name: exponentialRetryPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      const retryData = {\n        retryCount: 0,\n        retryInterval: 0\n      };\n      try {\n        const response = await next(request);\n        return retry(next, retryData, request, response);\n      } catch (e) {\n        const error: RestError = e;\n        return retry(next, retryData, request, error.response, error);\n      }\n    }\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  getTraceParentHeader,\n  OperationTracingOptions,\n  createSpanFunction,\n  SpanStatusCode,\n  isSpanContextValid\n} from \"@azure/core-tracing\";\nimport { SpanKind } from \"@azure/core-tracing\";\nimport { PipelineResponse, PipelineRequest, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\nimport { URL } from \"../util/url\";\nimport { getUserAgentValue } from \"../util/userAgent\";\n\nconst createSpan = createSpanFunction({\n  packagePrefix: \"\",\n  namespace: \"\"\n});\n\n/**\n * The programmatic identifier of the tracingPolicy.\n */\nexport const tracingPolicyName = \"tracingPolicy\";\n\n/**\n * Options to configure the tracing policy.\n */\nexport interface TracingPolicyOptions {\n  /**\n   * String prefix to add to the user agent logged as metadata\n   * on the generated Span.\n   * Defaults to an empty string.\n   */\n  userAgentPrefix?: string;\n}\n\n/**\n * A simple policy to create OpenTelemetry Spans for each request made by the pipeline\n * that has SpanOptions with a parent.\n * Requests made without a parent Span will not be recorded.\n * @param options - Options to configure the telemetry logged by the tracing policy.\n */\nexport function tracingPolicy(options: TracingPolicyOptions = {}): PipelinePolicy {\n  const userAgent = getUserAgentValue(options.userAgentPrefix);\n\n  return {\n    name: tracingPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.tracingOptions?.tracingContext) {\n        return next(request);\n      }\n\n      // create a new span\n      const tracingOptions: OperationTracingOptions = {\n        ...request.tracingOptions,\n        spanOptions: {\n          ...request.tracingOptions.spanOptions,\n          kind: SpanKind.CLIENT\n        }\n      };\n\n      const url = new URL(request.url);\n      const path = url.pathname || \"/\";\n\n      const { span } = createSpan(path, { tracingOptions });\n\n      span.setAttributes({\n        \"http.method\": request.method,\n        \"http.url\": request.url,\n        requestId: request.requestId\n      });\n\n      if (userAgent) {\n        span.setAttribute(\"http.user_agent\", userAgent);\n      }\n\n      try {\n        // set headers\n        const spanContext = span.spanContext();\n        const traceParentHeader = getTraceParentHeader(spanContext);\n        if (traceParentHeader && isSpanContextValid(spanContext)) {\n          request.headers.set(\"traceparent\", traceParentHeader);\n          const traceState = spanContext.traceState && spanContext.traceState.serialize();\n          // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n          if (traceState) {\n            request.headers.set(\"tracestate\", traceState);\n          }\n        }\n\n        const response = await next(request);\n        span.setAttribute(\"http.status_code\", response.status);\n        const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n        if (serviceRequestId) {\n          span.setAttribute(\"serviceRequestId\", serviceRequestId);\n        }\n        span.setStatus({\n          code: SpanStatusCode.OK\n        });\n        return response;\n      } catch (err) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err.message\n        });\n        span.setAttribute(\"http.status_code\", err.statusCode);\n        throw err;\n      } finally {\n        span.end();\n      }\n    }\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PipelineResponse, PipelineRequest, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\n\n/**\n * The programmatic identifier of the setClientRequestIdPolicy.\n */\nexport const setClientRequestIdPolicyName = \"setClientRequestIdPolicy\";\n\n/**\n * Each PipelineRequest gets a unique id upon creation.\n * This policy passes that unique id along via an HTTP header to enable better\n * telemetry and tracing.\n * @param requestIdHeaderName - The name of the header to pass the request ID to.\n */\nexport function setClientRequestIdPolicy(\n  requestIdHeaderName = \"x-ms-client-request-id\"\n): PipelinePolicy {\n  return {\n    name: setClientRequestIdPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.headers.has(requestIdHeaderName)) {\n        request.headers.set(requestIdHeaderName, request.requestId);\n      }\n      return next(request);\n    }\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PipelineResponse, PipelineRequest, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\nimport { delay } from \"../util/helpers\";\n\n/**\n * The programmatic identifier of the throttlingRetryPolicy.\n */\nexport const throttlingRetryPolicyName = \"throttlingRetryPolicy\";\n\n/**\n * Maximum number of retries for the throttling retry policy\n */\nexport const DEFAULT_CLIENT_MAX_RETRY_COUNT = 3;\n\n/**\n * A policy that retries when the server sends a 429 response with a Retry-After header.\n *\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n */\nexport function throttlingRetryPolicy(): PipelinePolicy {\n  return {\n    name: throttlingRetryPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      let response = await next(request);\n\n      for (let count = 0; count < DEFAULT_CLIENT_MAX_RETRY_COUNT; count++) {\n        if (response.status !== 429 && response.status !== 503) {\n          return response;\n        }\n        const retryAfterHeader = response.headers.get(\"Retry-After\");\n        if (!retryAfterHeader) {\n          break;\n        }\n        const delayInMs = parseRetryAfterHeader(retryAfterHeader);\n        if (!delayInMs) {\n          break;\n        }\n        await delay(delayInMs);\n        response = await next(request);\n      }\n      return response;\n    }\n  };\n}\n\n/**\n * Returns the number of milliseconds to wait based on a Retry-After header value.\n * Returns undefined if there is no valid value.\n * @param headerValue - An HTTP Retry-After header value.\n */\nfunction parseRetryAfterHeader(headerValue: string): number | undefined {\n  try {\n    const retryAfterInSeconds = Number(headerValue);\n    if (!Number.isNaN(retryAfterInSeconds)) {\n      return retryAfterInSeconds * 1000;\n    } else {\n      // It might be formatted as a date instead of a number of seconds\n\n      const now: number = Date.now();\n      const date: number = Date.parse(headerValue);\n      const diff = date - now;\n\n      return Number.isNaN(diff) ? undefined : diff;\n    }\n  } catch (e) {\n    return undefined;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PipelineResponse, PipelineRequest, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\nimport { logger } from \"../log\";\nimport { RestError } from \"../restError\";\nimport { delay, getRandomIntegerInclusive } from \"../util/helpers\";\n\nconst DEFAULT_CLIENT_RETRY_COUNT = 10;\n// intervals are in ms\nconst DEFAULT_CLIENT_RETRY_INTERVAL = 1000;\nconst DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 64;\n\n/**\n * The programmatic identifier of the systemErrorRetryPolicy.\n */\nexport const systemErrorRetryPolicyName = \"systemErrorRetryPolicy\";\n\ninterface RetryData {\n  retryCount: number;\n  retryInterval: number;\n  error?: RetryError;\n}\n\ninterface RetryError extends Error {\n  message: string;\n  code?: string;\n  innerError?: RetryError;\n}\n\n/**\n * Options that control how to retry failed requests.\n */\nexport interface SystemErrorRetryPolicyOptions {\n  /**\n   * The maximum number of retry attempts.  Defaults to 10.\n   */\n  maxRetries?: number;\n\n  /**\n   * The amount of delay in milliseconds between retry attempts. Defaults to 1000\n   * (1 second.) The delay increases exponentially with each retry up to a maximum\n   * specified by maxRetryDelayInMs.\n   */\n  retryDelayInMs?: number;\n\n  /**\n   * The maximum delay in milliseconds allowed before retrying an operation. Defaults\n   * to 64000 (64 seconds).\n   */\n  maxRetryDelayInMs?: number;\n}\n\n/**\n * A retry policy that specifically seeks to handle errors in the\n * underlying transport layer (e.g. DNS lookup failures) rather than\n * retryable error codes from the server itself.\n * @param options - Options that customize the policy.\n */\nexport function systemErrorRetryPolicy(\n  options: SystemErrorRetryPolicyOptions = {}\n): PipelinePolicy {\n  const retryCount = options.maxRetries ?? DEFAULT_CLIENT_RETRY_COUNT;\n  const retryInterval = options.retryDelayInMs ?? DEFAULT_CLIENT_RETRY_INTERVAL;\n  const maxRetryInterval = options.maxRetryDelayInMs ?? DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n\n  function shouldRetry(retryData: RetryData, err?: RetryError): boolean {\n    if (!isSystemError(err)) {\n      return false;\n    }\n    const currentCount = retryData.retryCount;\n    return currentCount <= retryCount;\n  }\n\n  function updateRetryData(retryData: RetryData, err?: RetryError): RetryData {\n    if (err) {\n      if (retryData.error) {\n        err.innerError = retryData.error;\n      }\n\n      retryData.error = err;\n    }\n\n    // Adjust retry count\n    retryData.retryCount++;\n\n    // Exponentially increase the delay each time\n    const exponentialDelay = retryInterval * Math.pow(2, retryData.retryCount);\n    // Don't let the delay exceed the maximum\n    const clampedExponentialDelay = Math.min(maxRetryInterval, exponentialDelay);\n    // Allow the final value to have some \"jitter\" (within 50% of the delay size) so\n    // that retries across multiple clients don't occur simultaneously.\n    const delayWithJitter =\n      clampedExponentialDelay / 2 + getRandomIntegerInclusive(0, clampedExponentialDelay / 2);\n\n    retryData.retryInterval = delayWithJitter;\n\n    return retryData;\n  }\n\n  async function retry(\n    next: SendRequest,\n    retryData: RetryData,\n    request: PipelineRequest,\n    response?: PipelineResponse,\n    requestError?: RetryError\n  ): Promise<PipelineResponse> {\n    retryData = updateRetryData(retryData, requestError);\n    if (shouldRetry(retryData, requestError)) {\n      try {\n        logger.info(`Retrying request in ${retryData.retryInterval}`);\n        await delay(retryData.retryInterval);\n        const res = await next(request);\n        return retry(next, retryData, request, res);\n      } catch (e) {\n        return retry(next, retryData, request, response, e);\n      }\n    } else if (requestError || !response) {\n      // If the operation failed in the end, return all errors instead of just the last one\n      const err =\n        retryData.error ||\n        new RestError(\"Failed to send the request.\", {\n          code: RestError.REQUEST_SEND_ERROR,\n          statusCode: response?.status,\n          request: response?.request,\n          response\n        });\n      throw err;\n    } else {\n      return response;\n    }\n  }\n\n  return {\n    name: systemErrorRetryPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      const retryData = {\n        retryCount: 0,\n        retryInterval: 0\n      };\n      try {\n        const response = await next(request);\n        return retry(next, retryData, request, response);\n      } catch (e) {\n        const error: RestError = e;\n        return retry(next, retryData, request, error.response, error);\n      }\n    }\n  };\n}\n\nfunction isSystemError(err?: RestError): boolean {\n  if (!err) {\n    return false;\n  }\n  return (\n    err.code === \"ETIMEDOUT\" ||\n    err.code === \"ESOCKETTIMEDOUT\" ||\n    err.code === \"ECONNREFUSED\" ||\n    err.code === \"ECONNRESET\" ||\n    err.code === \"ENOENT\"\n  );\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PipelineResponse, PipelineRequest, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\n\n/**\n * The programmatic identifier of the decompressResponsePolicy.\n */\nexport const decompressResponsePolicyName = \"decompressResponsePolicy\";\n\n/**\n * A policy to enable response decompression according to Accept-Encoding header\n * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding\n */\nexport function decompressResponsePolicy(): PipelinePolicy {\n  return {\n    name: decompressResponsePolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      // HEAD requests have no body\n      if (request.method !== \"HEAD\") {\n        request.headers.set(\"Accept-Encoding\", \"gzip,deflate\");\n      }\n      return next(request);\n    }\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as http from \"http\";\nimport * as https from \"https\";\nimport { HttpsProxyAgent, HttpsProxyAgentOptions } from \"https-proxy-agent\";\nimport { HttpProxyAgent, HttpProxyAgentOptions } from \"http-proxy-agent\";\nimport {\n  PipelineResponse,\n  PipelineRequest,\n  SendRequest,\n  ProxySettings,\n  HttpHeaders\n} from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\nimport { URL } from \"../util/url\";\n\nconst HTTPS_PROXY = \"HTTPS_PROXY\";\nconst HTTP_PROXY = \"HTTP_PROXY\";\nconst ALL_PROXY = \"ALL_PROXY\";\nconst NO_PROXY = \"NO_PROXY\";\n\n/**\n * The programmatic identifier of the proxyPolicy.\n */\nexport const proxyPolicyName = \"proxyPolicy\";\n\n/**\n * Stores the patterns specified in NO_PROXY environment variable.\n * @internal\n */\nexport const globalNoProxyList: string[] = [];\nlet noProxyListLoaded: boolean = false;\n\n/** A cache of whether a host should bypass the proxy. */\nconst globalBypassedMap: Map<string, boolean> = new Map();\n\nlet httpsProxyAgent: https.Agent | undefined;\nlet httpProxyAgent: http.Agent | undefined;\n\nfunction getEnvironmentValue(name: string): string | undefined {\n  if (process.env[name]) {\n    return process.env[name];\n  } else if (process.env[name.toLowerCase()]) {\n    return process.env[name.toLowerCase()];\n  }\n  return undefined;\n}\n\nfunction loadEnvironmentProxyValue(): string | undefined {\n  if (!process) {\n    return undefined;\n  }\n\n  const httpsProxy = getEnvironmentValue(HTTPS_PROXY);\n  const allProxy = getEnvironmentValue(ALL_PROXY);\n  const httpProxy = getEnvironmentValue(HTTP_PROXY);\n\n  return httpsProxy || allProxy || httpProxy;\n}\n\n/**\n * Check whether the host of a given `uri` matches any pattern in the no proxy list.\n * If there's a match, any request sent to the same host shouldn't have the proxy settings set.\n * This implementation is a port of https://github.com/Azure/azure-sdk-for-net/blob/8cca811371159e527159c7eb65602477898683e2/sdk/core/Azure.Core/src/Pipeline/Internal/HttpEnvironmentProxy.cs#L210\n */\nfunction isBypassed(\n  uri: string,\n  noProxyList: string[],\n  bypassedMap?: Map<string, boolean>\n): boolean | undefined {\n  if (noProxyList.length === 0) {\n    return false;\n  }\n  const host = new URL(uri).hostname;\n  if (bypassedMap?.has(host)) {\n    return bypassedMap.get(host);\n  }\n  let isBypassedFlag = false;\n  for (const pattern of noProxyList) {\n    if (pattern[0] === \".\") {\n      // This should match either domain it self or any subdomain or host\n      // .foo.com will match foo.com it self or *.foo.com\n      if (host.endsWith(pattern)) {\n        isBypassedFlag = true;\n      } else {\n        if (host.length === pattern.length - 1 && host === pattern.slice(1)) {\n          isBypassedFlag = true;\n        }\n      }\n    } else {\n      if (host === pattern) {\n        isBypassedFlag = true;\n      }\n    }\n  }\n  bypassedMap?.set(host, isBypassedFlag);\n  return isBypassedFlag;\n}\n\nexport function loadNoProxy(): string[] {\n  const noProxy = getEnvironmentValue(NO_PROXY);\n  noProxyListLoaded = true;\n  if (noProxy) {\n    return noProxy\n      .split(\",\")\n      .map((item) => item.trim())\n      .filter((item) => item.length);\n  }\n\n  return [];\n}\n\n/**\n * This method converts a proxy url into `ProxySettings` for use with ProxyPolicy.\n * If no argument is given, it attempts to parse a proxy URL from the environment\n * variables `HTTPS_PROXY` or `HTTP_PROXY`.\n * @param proxyUrl - The url of the proxy to use. May contain authentication information.\n */\nexport function getDefaultProxySettings(proxyUrl?: string): ProxySettings | undefined {\n  if (!proxyUrl) {\n    proxyUrl = loadEnvironmentProxyValue();\n    if (!proxyUrl) {\n      return undefined;\n    }\n  }\n\n  const parsedUrl = new URL(proxyUrl);\n  const schema = parsedUrl.protocol ? parsedUrl.protocol + \"//\" : \"\";\n  return {\n    host: schema + parsedUrl.hostname,\n    port: Number.parseInt(parsedUrl.port || \"80\"),\n    username: parsedUrl.username,\n    password: parsedUrl.password\n  };\n}\n\n/**\n * @internal\n */\nexport function getProxyAgentOptions(\n  proxySettings: ProxySettings,\n  requestHeaders: HttpHeaders\n): HttpProxyAgentOptions {\n  let parsedProxyUrl: URL;\n  try {\n    parsedProxyUrl = new URL(proxySettings.host);\n  } catch (_error) {\n    throw new Error(\n      `Expecting a valid host string in proxy settings, but found \"${proxySettings.host}\".`\n    );\n  }\n\n  const proxyAgentOptions: HttpsProxyAgentOptions = {\n    hostname: parsedProxyUrl.hostname,\n    port: proxySettings.port,\n    protocol: parsedProxyUrl.protocol,\n    headers: requestHeaders.toJSON()\n  };\n  if (proxySettings.username && proxySettings.password) {\n    proxyAgentOptions.auth = `${proxySettings.username}:${proxySettings.password}`;\n  } else if (proxySettings.username) {\n    proxyAgentOptions.auth = `${proxySettings.username}`;\n  }\n  return proxyAgentOptions;\n}\n\nfunction setProxyAgentOnRequest(request: PipelineRequest): void {\n  const url = new URL(request.url);\n\n  const isInsecure = url.protocol !== \"https:\";\n\n  const proxySettings = request.proxySettings;\n  if (proxySettings) {\n    if (isInsecure) {\n      if (!httpProxyAgent) {\n        const proxyAgentOptions = getProxyAgentOptions(proxySettings, request.headers);\n        httpProxyAgent = new HttpProxyAgent(proxyAgentOptions);\n      }\n      request.agent = httpProxyAgent;\n    } else {\n      if (!httpsProxyAgent) {\n        const proxyAgentOptions = getProxyAgentOptions(proxySettings, request.headers);\n        httpsProxyAgent = new HttpsProxyAgent(proxyAgentOptions);\n      }\n      request.agent = httpsProxyAgent;\n    }\n  }\n}\n\n/**\n * A policy that allows one to apply proxy settings to all requests.\n * If not passed static settings, they will be retrieved from the HTTPS_PROXY\n * or HTTP_PROXY environment variables.\n * @param proxySettings - ProxySettings to use on each request.\n * @param options - additional settings, for example, custom NO_PROXY patterns\n */\nexport function proxyPolicy(\n  proxySettings = getDefaultProxySettings(),\n  options?: {\n    /** a list of patterns to override those loaded from NO_PROXY environment variable. */\n    customNoProxyList?: string[];\n  }\n): PipelinePolicy {\n  if (!noProxyListLoaded) {\n    globalNoProxyList.push(...loadNoProxy());\n  }\n  return {\n    name: proxyPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (\n        !request.proxySettings &&\n        !isBypassed(\n          request.url,\n          options?.customNoProxyList ?? globalNoProxyList,\n          options?.customNoProxyList ? undefined : globalBypassedMap\n        )\n      ) {\n        request.proxySettings = proxySettings;\n      }\n\n      if (request.proxySettings) {\n        setProxyAgentOnRequest(request);\n      }\n      return next(request);\n    }\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport FormData from \"form-data\";\nimport { PipelineResponse, PipelineRequest, SendRequest, FormDataMap } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\n\n/**\n * The programmatic identifier of the formDataPolicy.\n */\nexport const formDataPolicyName = \"formDataPolicy\";\n\n/**\n * A policy that encodes FormData on the request into the body.\n */\nexport function formDataPolicy(): PipelinePolicy {\n  return {\n    name: formDataPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (request.formData) {\n        prepareFormData(request.formData, request);\n      }\n      return next(request);\n    }\n  };\n}\n\nasync function prepareFormData(formData: FormDataMap, request: PipelineRequest): Promise<void> {\n  const requestForm = new FormData();\n  for (const formKey of Object.keys(formData)) {\n    const formValue = formData[formKey];\n    if (Array.isArray(formValue)) {\n      for (const subValue of formValue) {\n        requestForm.append(formKey, subValue);\n      }\n    } else {\n      requestForm.append(formKey, formValue);\n    }\n  }\n\n  request.body = requestForm;\n  request.formData = undefined;\n  const contentType = request.headers.get(\"Content-Type\");\n  if (contentType && contentType.indexOf(\"multipart/form-data\") !== -1) {\n    request.headers.set(\n      \"Content-Type\",\n      `multipart/form-data; boundary=${requestForm.getBoundary()}`\n    );\n  }\n  try {\n    const contentLength = await new Promise<number>((resolve, reject) => {\n      requestForm.getLength((err, length) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(length);\n        }\n      });\n    });\n    request.headers.set(\"Content-Length\", contentLength);\n  } catch (e) {\n    // ignore setting the length if this fails\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  PipelineRequest,\n  PipelineResponse,\n  HttpClient,\n  SendRequest,\n  ProxySettings\n} from \"./interfaces\";\nimport { LogPolicyOptions, logPolicy } from \"./policies/logPolicy\";\nimport { UserAgentPolicyOptions, userAgentPolicy } from \"./policies/userAgentPolicy\";\nimport { RedirectPolicyOptions, redirectPolicy } from \"./policies/redirectPolicy\";\nimport {\n  ExponentialRetryPolicyOptions,\n  exponentialRetryPolicy\n} from \"./policies/exponentialRetryPolicy\";\nimport { tracingPolicy } from \"./policies/tracingPolicy\";\nimport { setClientRequestIdPolicy } from \"./policies/setClientRequestIdPolicy\";\nimport { throttlingRetryPolicy } from \"./policies/throttlingRetryPolicy\";\nimport { systemErrorRetryPolicy } from \"./policies/systemErrorRetryPolicy\";\nimport { decompressResponsePolicy } from \"./policies/decompressResponsePolicy\";\nimport { proxyPolicy } from \"./policies/proxyPolicy\";\nimport { isNode } from \"./util/helpers\";\nimport { formDataPolicy } from \"./policies/formDataPolicy\";\n\n/**\n * Policies are executed in phases.\n * The execution order is:\n * 1. Serialize Phase\n * 2. Policies not in a phase\n * 3. Deserialize Phase\n * 4. Retry Phase\n */\nexport type PipelinePhase = \"Deserialize\" | \"Serialize\" | \"Retry\";\n\nconst ValidPhaseNames = new Set<PipelinePhase>([\"Deserialize\", \"Serialize\", \"Retry\"]);\n\n/**\n * Options when adding a policy to the pipeline.\n * Used to express dependencies on other policies.\n */\nexport interface AddPolicyOptions {\n  /**\n   * Policies that this policy must come before.\n   */\n  beforePolicies?: string[];\n  /**\n   * Policies that this policy must come after.\n   */\n  afterPolicies?: string[];\n  /**\n   * The phase that this policy must come after.\n   */\n  afterPhase?: PipelinePhase;\n  /**\n   * The phase this policy belongs to.\n   */\n  phase?: PipelinePhase;\n}\n\n/**\n * A pipeline policy manipulates a request as it travels through the pipeline.\n * It is conceptually a middleware that is allowed to modify the request before\n * it is made as well as the response when it is received.\n */\nexport interface PipelinePolicy {\n  /**\n   * The policy name. Must be a unique string in the pipeline.\n   */\n  name: string;\n  /**\n   * The main method to implement that manipulates a request/response.\n   * @param request - The request being performed.\n   * @param next - The next policy in the pipeline. Must be called to continue the pipeline.\n   */\n  sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse>;\n}\n\n/**\n * Represents a pipeline for making a HTTP request to a URL.\n * Pipelines can have multiple policies to manage manipulating each request\n * before and after it is made to the server.\n */\nexport interface Pipeline {\n  /**\n   * Add a new policy to the pipeline.\n   * @param policy - A policy that manipulates a request.\n   * @param options - A set of options for when the policy should run.\n   */\n  addPolicy(policy: PipelinePolicy, options?: AddPolicyOptions): void;\n  /**\n   * Remove a policy from the pipeline.\n   * @param options - Options that let you specify which policies to remove.\n   */\n  removePolicy(options: { name?: string; phase?: PipelinePhase }): PipelinePolicy[];\n  /**\n   * Uses the pipeline to make a HTTP request.\n   * @param httpClient - The HttpClient that actually performs the request.\n   * @param request - The request to be made.\n   */\n  sendRequest(httpClient: HttpClient, request: PipelineRequest): Promise<PipelineResponse>;\n  /**\n   * Returns the current set of policies in the pipeline in the order in which\n   * they will be applied to the request. Later in the list is closer to when\n   * the request is performed.\n   */\n  getOrderedPolicies(): PipelinePolicy[];\n  /**\n   * Duplicates this pipeline to allow for modifying an existing one without mutating it.\n   */\n  clone(): Pipeline;\n}\n\ninterface PipelineDescriptor {\n  policy: PipelinePolicy;\n  options: AddPolicyOptions;\n}\n\ninterface PolicyGraphNode {\n  policy: PipelinePolicy;\n  dependsOn: Set<PolicyGraphNode>;\n  dependants: Set<PolicyGraphNode>;\n  afterPhase?: Set<PolicyGraphNode>;\n}\n\n/**\n * A private implementation of Pipeline.\n * Do not export this class from the package.\n * @internal\n */\nclass HttpPipeline implements Pipeline {\n  private _policies: PipelineDescriptor[] = [];\n  private _orderedPolicies?: PipelinePolicy[];\n\n  private constructor(policies: PipelineDescriptor[] = []) {\n    this._policies = policies;\n    this._orderedPolicies = undefined;\n  }\n\n  public addPolicy(policy: PipelinePolicy, options: AddPolicyOptions = {}): void {\n    if (options.phase && options.afterPhase) {\n      throw new Error(\"Policies inside a phase cannot specify afterPhase.\");\n    }\n    if (options.phase && !ValidPhaseNames.has(options.phase)) {\n      throw new Error(`Invalid phase name: ${options.phase}`);\n    }\n    if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {\n      throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);\n    }\n    this._policies.push({\n      policy,\n      options\n    });\n    this._orderedPolicies = undefined;\n  }\n\n  public removePolicy(options: { name?: string; phase?: string }): PipelinePolicy[] {\n    const removedPolicies: PipelinePolicy[] = [];\n\n    this._policies = this._policies.filter((policyDescriptor) => {\n      if (\n        (options.name && policyDescriptor.policy.name === options.name) ||\n        (options.phase && policyDescriptor.options.phase === options.phase)\n      ) {\n        removedPolicies.push(policyDescriptor.policy);\n        return false;\n      } else {\n        return true;\n      }\n    });\n    this._orderedPolicies = undefined;\n\n    return removedPolicies;\n  }\n\n  public sendRequest(httpClient: HttpClient, request: PipelineRequest): Promise<PipelineResponse> {\n    const policies = this.getOrderedPolicies();\n\n    const pipeline = policies.reduceRight<SendRequest>(\n      (next, policy) => {\n        return (req: PipelineRequest) => {\n          return policy.sendRequest(req, next);\n        };\n      },\n      (req: PipelineRequest) => httpClient.sendRequest(req)\n    );\n\n    return pipeline(request);\n  }\n\n  public getOrderedPolicies(): PipelinePolicy[] {\n    if (!this._orderedPolicies) {\n      this._orderedPolicies = this.orderPolicies();\n    }\n    return this._orderedPolicies;\n  }\n\n  public clone(): Pipeline {\n    return new HttpPipeline(this._policies);\n  }\n\n  public static create(): Pipeline {\n    return new HttpPipeline();\n  }\n\n  private orderPolicies(): PipelinePolicy[] {\n    /**\n     * The goal of this method is to reliably order pipeline policies\n     * based on their declared requirements when they were added.\n     *\n     * Order is first determined by phase:\n     *\n     * 1. Serialize Phase\n     * 2. Policies not in a phase\n     * 3. Deserialize Phase\n     * 4. Retry Phase\n     *\n     * Within each phase, policies are executed in the order\n     * they were added unless they were specified to execute\n     * before/after other policies or after a particular phase.\n     *\n     * To determine the final order, we will walk the policy list\n     * in phase order multiple times until all dependencies are\n     * satisfied.\n     *\n     * `afterPolicies` are the set of policies that must be\n     * executed before a given policy. This requirement is\n     * considered satisfied when each of the listed policies\n     * have been scheduled.\n     *\n     * `beforePolicies` are the set of policies that must be\n     * executed after a given policy. Since this dependency\n     * can be expressed by converting it into a equivalent\n     * `afterPolicies` declarations, they are normalized\n     * into that form for simplicity.\n     *\n     * An `afterPhase` dependency is considered satisfied when all\n     * policies in that phase have scheduled.\n     *\n     */\n    const result: PipelinePolicy[] = [];\n\n    // Track all policies we know about.\n    const policyMap: Map<string, PolicyGraphNode> = new Map<string, PolicyGraphNode>();\n\n    // Track policies for each phase.\n    const serializePhase = new Set<PolicyGraphNode>();\n    const noPhase = new Set<PolicyGraphNode>();\n    const deserializePhase = new Set<PolicyGraphNode>();\n    const retryPhase = new Set<PolicyGraphNode>();\n\n    // a list of phases in order\n    const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase];\n\n    // Small helper function to map phase name to each Set bucket.\n    function getPhase(phase: PipelinePhase | undefined): Set<PolicyGraphNode> {\n      if (phase === \"Retry\") {\n        return retryPhase;\n      } else if (phase === \"Serialize\") {\n        return serializePhase;\n      } else if (phase === \"Deserialize\") {\n        return deserializePhase;\n      } else {\n        return noPhase;\n      }\n    }\n\n    // First walk each policy and create a node to track metadata.\n    for (const descriptor of this._policies) {\n      const policy = descriptor.policy;\n      const options = descriptor.options;\n      const policyName = policy.name;\n      if (policyMap.has(policyName)) {\n        throw new Error(\"Duplicate policy names not allowed in pipeline\");\n      }\n      const node: PolicyGraphNode = {\n        policy,\n        dependsOn: new Set<PolicyGraphNode>(),\n        dependants: new Set<PolicyGraphNode>()\n      };\n      if (options.afterPhase) {\n        node.afterPhase = getPhase(options.afterPhase);\n      }\n      policyMap.set(policyName, node);\n      const phase = getPhase(options.phase);\n      phase.add(node);\n    }\n\n    // Now that each policy has a node, connect dependency references.\n    for (const descriptor of this._policies) {\n      const { policy, options } = descriptor;\n      const policyName = policy.name;\n      const node = policyMap.get(policyName);\n      if (!node) {\n        throw new Error(`Missing node for policy ${policyName}`);\n      }\n\n      if (options.afterPolicies) {\n        for (const afterPolicyName of options.afterPolicies) {\n          const afterNode = policyMap.get(afterPolicyName);\n          if (afterNode) {\n            // Linking in both directions helps later\n            // when we want to notify dependants.\n            node.dependsOn.add(afterNode);\n            afterNode.dependants.add(node);\n          }\n        }\n      }\n      if (options.beforePolicies) {\n        for (const beforePolicyName of options.beforePolicies) {\n          const beforeNode = policyMap.get(beforePolicyName);\n          if (beforeNode) {\n            // To execute before another node, make it\n            // depend on the current node.\n            beforeNode.dependsOn.add(node);\n            node.dependants.add(beforeNode);\n          }\n        }\n      }\n    }\n\n    function walkPhase(phase: Set<PolicyGraphNode>): void {\n      // Sets iterate in insertion order\n      for (const node of phase) {\n        if (node.afterPhase && node.afterPhase.size) {\n          // If this node is waiting on a phase to complete,\n          // we need to skip it for now.\n          continue;\n        }\n        if (node.dependsOn.size === 0) {\n          // If there's nothing else we're waiting for, we can\n          // add this policy to the result list.\n          result.push(node.policy);\n          // Notify anything that depends on this policy that\n          // the policy has been scheduled.\n          for (const dependant of node.dependants) {\n            dependant.dependsOn.delete(node);\n          }\n          policyMap.delete(node.policy.name);\n          phase.delete(node);\n        }\n      }\n    }\n\n    function walkPhases(): void {\n      let noPhaseRan = false;\n\n      for (const phase of orderedPhases) {\n        walkPhase(phase);\n        if (phase === noPhase) {\n          noPhaseRan = true;\n        }\n        // if the phase isn't complete\n        if (phase.size > 0 && phase !== noPhase) {\n          if (noPhaseRan === false) {\n            // Try running noPhase to see if that unblocks this phase next tick.\n            // This can happen if a phase that happens before noPhase\n            // is waiting on a noPhase policy to complete.\n            walkPhase(noPhase);\n          }\n          // Don't proceed to the next phase until this phase finishes.\n          return;\n        }\n      }\n    }\n\n    // Iterate until we've put every node in the result list.\n    while (policyMap.size > 0) {\n      const initialResultLength = result.length;\n      // Keep walking each phase in order until we can order every node.\n      walkPhases();\n      // The result list *should* get at least one larger each time.\n      // Otherwise, we're going to loop forever.\n      if (result.length <= initialResultLength) {\n        throw new Error(\"Cannot satisfy policy dependencies due to requirements cycle.\");\n      }\n    }\n\n    return result;\n  }\n}\n\n/**\n * Creates a totally empty pipeline.\n * Useful for testing or creating a custom one.\n */\nexport function createEmptyPipeline(): Pipeline {\n  return HttpPipeline.create();\n}\n\n/**\n * Defines options that are used to configure the HTTP pipeline for\n * an SDK client.\n */\nexport interface PipelineOptions {\n  /**\n   * Options that control how to retry failed requests.\n   */\n  retryOptions?: ExponentialRetryPolicyOptions;\n\n  /**\n   * Options to configure a proxy for outgoing requests.\n   */\n  proxyOptions?: ProxySettings;\n\n  /**\n   * Options for how redirect responses are handled.\n   */\n  redirectOptions?: RedirectPolicyOptions;\n\n  /**\n   * Options for adding user agent details to outgoing requests.\n   */\n  userAgentOptions?: UserAgentPolicyOptions;\n}\n\n/**\n * Defines options that are used to configure internal options of\n * the HTTP pipeline for an SDK client.\n */\nexport interface InternalPipelineOptions extends PipelineOptions {\n  /**\n   * Options to configure request/response logging.\n   */\n  loggingOptions?: LogPolicyOptions;\n}\n\n/**\n * Create a new pipeline with a default set of customizable policies.\n * @param options - Options to configure a custom pipeline.\n */\nexport function createPipelineFromOptions(options: InternalPipelineOptions): Pipeline {\n  const pipeline = HttpPipeline.create();\n\n  if (isNode) {\n    pipeline.addPolicy(proxyPolicy(options.proxyOptions));\n    pipeline.addPolicy(decompressResponsePolicy());\n  }\n\n  pipeline.addPolicy(formDataPolicy());\n  pipeline.addPolicy(tracingPolicy(options.userAgentOptions));\n  pipeline.addPolicy(userAgentPolicy(options.userAgentOptions));\n  pipeline.addPolicy(setClientRequestIdPolicy());\n  pipeline.addPolicy(throttlingRetryPolicy(), { phase: \"Retry\" });\n  pipeline.addPolicy(systemErrorRetryPolicy(options.retryOptions), { phase: \"Retry\" });\n  pipeline.addPolicy(exponentialRetryPolicy(options.retryOptions), { phase: \"Retry\" });\n  pipeline.addPolicy(redirectPolicy(options.redirectOptions), { afterPhase: \"Retry\" });\n  pipeline.addPolicy(logPolicy(options.loggingOptions), { afterPhase: \"Retry\" });\n\n  return pipeline;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpHeaders, RawHttpHeaders } from \"./interfaces\";\n\nfunction normalizeName(name: string): string {\n  return name.toLowerCase();\n}\n\nclass HttpHeadersImpl implements HttpHeaders {\n  private readonly _headersMap: Map<string, string>;\n\n  constructor(rawHeaders?: RawHttpHeaders) {\n    this._headersMap = new Map<string, string>();\n    if (rawHeaders) {\n      for (const headerName of Object.keys(rawHeaders)) {\n        this.set(headerName, rawHeaders[headerName]);\n      }\n    }\n  }\n\n  /**\n   * Set a header in this collection with the provided name and value. The name is\n   * case-insensitive.\n   * @param name - The name of the header to set. This value is case-insensitive.\n   * @param value - The value of the header to set.\n   */\n  public set(name: string, value: string | number): void {\n    this._headersMap.set(normalizeName(name), String(value));\n  }\n\n  /**\n   * Get the header value for the provided header name, or undefined if no header exists in this\n   * collection with the provided name.\n   * @param name - The name of the header. This value is case-insensitive.\n   */\n  public get(name: string): string | undefined {\n    return this._headersMap.get(normalizeName(name));\n  }\n\n  /**\n   * Get whether or not this header collection contains a header entry for the provided header name.\n   * @param name - The name of the header to set. This value is case-insensitive.\n   */\n  public has(name: string): boolean {\n    return this._headersMap.has(normalizeName(name));\n  }\n\n  /**\n   * Remove the header with the provided headerName.\n   * @param name - The name of the header to remove.\n   */\n  public delete(name: string): void {\n    this._headersMap.delete(normalizeName(name));\n  }\n\n  /**\n   * Get the JSON object representation of this HTTP header collection.\n   */\n  public toJSON(): RawHttpHeaders {\n    const result: RawHttpHeaders = {};\n    for (const [key, value] of this._headersMap) {\n      result[key] = value;\n    }\n    return result;\n  }\n\n  /**\n   * Get the string representation of this HTTP header collection.\n   */\n  public toString(): string {\n    return JSON.stringify(this.toJSON());\n  }\n\n  /**\n   * Iterate over tuples of header [name, value] pairs.\n   */\n  [Symbol.iterator](): Iterator<[string, string]> {\n    return this._headersMap.entries();\n  }\n}\n\n/**\n * Creates an object that satisfies the `HttpHeaders` interface.\n * @param rawHeaders - A simple object representing initial headers\n */\nexport function createHttpHeaders(rawHeaders?: RawHttpHeaders): HttpHeaders {\n  return new HttpHeadersImpl(rawHeaders);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as http from \"http\";\nimport * as https from \"https\";\nimport * as zlib from \"zlib\";\nimport { Transform } from \"stream\";\nimport { AbortController, AbortError } from \"@azure/abort-controller\";\nimport {\n  HttpClient,\n  PipelineRequest,\n  PipelineResponse,\n  TransferProgressEvent,\n  HttpHeaders,\n  RequestBodyType\n} from \"./interfaces\";\nimport { createHttpHeaders } from \"./httpHeaders\";\nimport { RestError } from \"./restError\";\nimport { URL } from \"./util/url\";\nimport { IncomingMessage } from \"http\";\nimport { logger } from \"./log\";\n\nfunction isReadableStream(body: any): body is NodeJS.ReadableStream {\n  return body && typeof body.pipe === \"function\";\n}\n\nfunction isStreamComplete(stream: NodeJS.ReadableStream): Promise<void> {\n  return new Promise((resolve) => {\n    stream.on(\"close\", resolve);\n    stream.on(\"end\", resolve);\n    stream.on(\"error\", resolve);\n  });\n}\n\nfunction isArrayBuffer(body: any): body is ArrayBuffer | ArrayBufferView {\n  return body && typeof body.byteLength === \"number\";\n}\n\nclass ReportTransform extends Transform {\n  private loadedBytes = 0;\n  private progressCallback: (progress: TransferProgressEvent) => void;\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  _transform(chunk: string | Buffer, _encoding: string, callback: Function): void {\n    this.push(chunk);\n    this.loadedBytes += chunk.length;\n    try {\n      this.progressCallback({ loadedBytes: this.loadedBytes });\n      callback();\n    } catch (e) {\n      callback(e);\n    }\n  }\n\n  constructor(progressCallback: (progress: TransferProgressEvent) => void) {\n    super();\n    this.progressCallback = progressCallback;\n  }\n}\n\n/**\n * A HttpClient implementation that uses Node's \"https\" module to send HTTPS requests.\n * @internal\n */\nclass NodeHttpClient implements HttpClient {\n  private httpsKeepAliveAgent?: https.Agent;\n  private httpKeepAliveAgent?: http.Agent;\n\n  /**\n   * Makes a request over an underlying transport layer and returns the response.\n   * @param request - The request to be made.\n   */\n  public async sendRequest(request: PipelineRequest): Promise<PipelineResponse> {\n    const abortController = new AbortController();\n    let abortListener: ((event: any) => void) | undefined;\n    if (request.abortSignal) {\n      if (request.abortSignal.aborted) {\n        throw new AbortError(\"The operation was aborted.\");\n      }\n\n      abortListener = (event: Event) => {\n        if (event.type === \"abort\") {\n          abortController.abort();\n        }\n      };\n      request.abortSignal.addEventListener(\"abort\", abortListener);\n    }\n\n    if (request.timeout > 0) {\n      setTimeout(() => {\n        abortController.abort();\n      }, request.timeout);\n    }\n\n    const acceptEncoding = request.headers.get(\"Accept-Encoding\");\n    const shouldDecompress =\n      acceptEncoding?.includes(\"gzip\") || acceptEncoding?.includes(\"deflate\");\n    let body = request.body;\n\n    if (body && !request.headers.has(\"Content-Length\")) {\n      const bodyLength = getBodyLength(body);\n      if (bodyLength !== null) {\n        request.headers.set(\"Content-Length\", bodyLength);\n      }\n    }\n\n    let responseStream: NodeJS.ReadableStream | undefined;\n    try {\n      if (body && request.onUploadProgress) {\n        const onUploadProgress = request.onUploadProgress;\n        const uploadReportStream = new ReportTransform(onUploadProgress);\n        uploadReportStream.on(\"error\", (e) => {\n          logger.error(\"Error in upload progress\", e);\n        });\n        if (isReadableStream(body)) {\n          body.pipe(uploadReportStream);\n        } else {\n          uploadReportStream.end(body);\n        }\n\n        body = uploadReportStream;\n      }\n\n      const res = await this.makeRequest(request, abortController, body);\n\n      const headers = getResponseHeaders(res);\n\n      const status = res.statusCode ?? 0;\n      const response: PipelineResponse = {\n        status,\n        headers,\n        request\n      };\n\n      // Responses to HEAD must not have a body.\n      // If they do return a body, that body must be ignored.\n      if (request.method === \"HEAD\") {\n        res.destroy();\n        return response;\n      }\n\n      responseStream = shouldDecompress ? getDecodedResponseStream(res, headers) : res;\n\n      const onDownloadProgress = request.onDownloadProgress;\n      if (onDownloadProgress) {\n        const downloadReportStream = new ReportTransform(onDownloadProgress);\n        downloadReportStream.on(\"error\", (e) => {\n          logger.error(\"Error in download progress\", e);\n        });\n        responseStream.pipe(downloadReportStream);\n        responseStream = downloadReportStream;\n      }\n\n      if (request.streamResponseStatusCodes?.has(response.status)) {\n        response.readableStreamBody = responseStream;\n      } else {\n        response.bodyAsText = await streamToText(responseStream);\n      }\n\n      return response;\n    } finally {\n      // clean up event listener\n      if (request.abortSignal && abortListener) {\n        let uploadStreamDone = Promise.resolve();\n        if (isReadableStream(body)) {\n          uploadStreamDone = isStreamComplete(body as NodeJS.ReadableStream);\n        }\n        let downloadStreamDone = Promise.resolve();\n        if (isReadableStream(responseStream)) {\n          downloadStreamDone = isStreamComplete(responseStream);\n        }\n\n        Promise.all([uploadStreamDone, downloadStreamDone])\n          .then(() => {\n            // eslint-disable-next-line promise/always-return\n            if (abortListener) {\n              request.abortSignal?.removeEventListener(\"abort\", abortListener);\n            }\n          })\n          .catch((e) => {\n            logger.warning(\"Error when cleaning up abortListener on httpRequest\", e);\n          });\n      }\n    }\n  }\n\n  private makeRequest(\n    request: PipelineRequest,\n    abortController: AbortController,\n    body?: RequestBodyType\n  ): Promise<http.IncomingMessage> {\n    const url = new URL(request.url);\n\n    const isInsecure = url.protocol !== \"https:\";\n\n    if (isInsecure && !request.allowInsecureConnection) {\n      throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n    }\n\n    const agent = (request.agent as http.Agent) ?? this.getOrCreateAgent(request, isInsecure);\n    const options: http.RequestOptions = {\n      agent,\n      hostname: url.hostname,\n      path: `${url.pathname}${url.search}`,\n      port: url.port,\n      method: request.method,\n      headers: request.headers.toJSON()\n    };\n\n    return new Promise<http.IncomingMessage>((resolve, reject) => {\n      const req = isInsecure ? http.request(options, resolve) : https.request(options, resolve);\n\n      req.once(\"error\", (err) => {\n        reject(new RestError(err.message, { code: RestError.REQUEST_SEND_ERROR, request }));\n      });\n      abortController.signal.addEventListener(\"abort\", () => {\n        req.abort();\n        reject(new AbortError(\"The operation was aborted.\"));\n      });\n      if (body && isReadableStream(body)) {\n        body.pipe(req);\n      } else if (body) {\n        if (typeof body === \"string\" || Buffer.isBuffer(body)) {\n          req.end(body);\n        } else if (isArrayBuffer(body)) {\n          req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body));\n        } else {\n          logger.error(\"Unrecognized body type\", body);\n          throw new RestError(\"Unrecognized body type\");\n        }\n      } else {\n        // streams don't like \"undefined\" being passed as data\n        req.end();\n      }\n    });\n  }\n\n  private getOrCreateAgent(request: PipelineRequest, isInsecure: boolean): http.Agent {\n    if (!request.disableKeepAlive) {\n      if (isInsecure) {\n        if (!this.httpKeepAliveAgent) {\n          this.httpKeepAliveAgent = new http.Agent({\n            keepAlive: true\n          });\n        }\n\n        return this.httpKeepAliveAgent;\n      } else {\n        if (!this.httpsKeepAliveAgent) {\n          this.httpsKeepAliveAgent = new https.Agent({\n            keepAlive: true\n          });\n        }\n\n        return this.httpsKeepAliveAgent;\n      }\n    } else if (isInsecure) {\n      return http.globalAgent;\n    } else {\n      return https.globalAgent;\n    }\n  }\n}\n\nfunction getResponseHeaders(res: IncomingMessage): HttpHeaders {\n  const headers = createHttpHeaders();\n  for (const header of Object.keys(res.headers)) {\n    const value = res.headers[header];\n    if (Array.isArray(value)) {\n      if (value.length > 0) {\n        headers.set(header, value[0]);\n      }\n    } else if (value) {\n      headers.set(header, value);\n    }\n  }\n  return headers;\n}\n\nfunction getDecodedResponseStream(\n  stream: IncomingMessage,\n  headers: HttpHeaders\n): NodeJS.ReadableStream {\n  const contentEncoding = headers.get(\"Content-Encoding\");\n  if (contentEncoding === \"gzip\") {\n    const unzip = zlib.createGunzip();\n    stream.pipe(unzip);\n    return unzip;\n  } else if (contentEncoding === \"deflate\") {\n    const inflate = zlib.createInflate();\n    stream.pipe(inflate);\n    return inflate;\n  }\n\n  return stream;\n}\n\nfunction streamToText(stream: NodeJS.ReadableStream): Promise<string> {\n  return new Promise<string>((resolve, reject) => {\n    const buffer: Buffer[] = [];\n\n    stream.on(\"data\", (chunk) => {\n      if (Buffer.isBuffer(chunk)) {\n        buffer.push(chunk);\n      } else {\n        buffer.push(Buffer.from(chunk));\n      }\n    });\n    stream.on(\"end\", () => {\n      resolve(Buffer.concat(buffer).toString(\"utf8\"));\n    });\n    stream.on(\"error\", (e) => {\n      reject(\n        new RestError(`Error reading response as text: ${e.message}`, {\n          code: RestError.PARSE_ERROR\n        })\n      );\n    });\n  });\n}\n\n/** @internal */\nexport function getBodyLength(body: RequestBodyType): number | null {\n  if (!body) {\n    return 0;\n  } else if (Buffer.isBuffer(body)) {\n    return body.length;\n  } else if (isReadableStream(body)) {\n    return null;\n  } else if (isArrayBuffer(body)) {\n    return body.byteLength;\n  } else if (typeof body === \"string\") {\n    return Buffer.from(body).length;\n  } else {\n    return null;\n  }\n}\n\n/**\n * Create a new HttpClient instance for the NodeJS environment.\n * @internal\n */\nexport function createNodeHttpClient(): HttpClient {\n  return new NodeHttpClient();\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpClient } from \"./interfaces\";\nimport { createNodeHttpClient } from \"./nodeHttpClient\";\n\n/**\n * Create the correct HttpClient for the current environment.\n */\nexport function createDefaultHttpClient(): HttpClient {\n  return createNodeHttpClient();\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { v4 as uuidv4 } from \"uuid\";\n\n/**\n * Generated Universally Unique Identifier\n *\n * @returns RFC4122 v4 UUID.\n * @internal\n */\nexport function generateUuid(): string {\n  return uuidv4();\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  PipelineRequest,\n  TransferProgressEvent,\n  RequestBodyType,\n  HttpMethods,\n  HttpHeaders,\n  FormDataMap,\n  ProxySettings\n} from \"./interfaces\";\nimport { createHttpHeaders } from \"./httpHeaders\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { generateUuid } from \"./util/uuid\";\nimport { OperationTracingOptions } from \"@azure/core-tracing\";\n\n/**\n * Settings to initialize a request.\n * Almost equivalent to Partial<PipelineRequest>, but url is mandatory.\n */\nexport interface PipelineRequestOptions {\n  /**\n   * The URL to make the request to.\n   */\n  url: string;\n\n  /**\n   * The HTTP method to use when making the request.\n   */\n  method?: HttpMethods;\n\n  /**\n   * The HTTP headers to use when making the request.\n   */\n  headers?: HttpHeaders;\n\n  /**\n   * The number of milliseconds a request can take before automatically being terminated.\n   * If the request is terminated, an `AbortError` is thrown.\n   * Defaults to 0, which disables the timeout.\n   */\n  timeout?: number;\n\n  /**\n   * If credentials (cookies) should be sent along during an XHR.\n   * Defaults to false.\n   */\n  withCredentials?: boolean;\n\n  /**\n   * A unique identifier for the request. Used for logging and tracing.\n   */\n  requestId?: string;\n\n  /**\n   * The HTTP body content (if any)\n   */\n  body?: RequestBodyType;\n\n  /**\n   * To simulate a browser form post\n   */\n  formData?: FormDataMap;\n\n  /**\n   * A list of response status codes whose corresponding PipelineResponse body should be treated as a stream.\n   */\n  streamResponseStatusCodes?: Set<number>;\n\n  /**\n   * Proxy configuration.\n   */\n  proxySettings?: ProxySettings;\n\n  /**\n   * If the connection should not be reused.\n   */\n  disableKeepAlive?: boolean;\n\n  /**\n   * Used to abort the request later.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Options used to create a span when tracing is enabled.\n   */\n  tracingOptions?: OperationTracingOptions;\n\n  /**\n   * Callback which fires upon upload progress.\n   */\n  onUploadProgress?: (progress: TransferProgressEvent) => void;\n\n  /** Callback which fires upon download progress. */\n  onDownloadProgress?: (progress: TransferProgressEvent) => void;\n\n  /** Set to true if the request is sent over HTTP instead of HTTPS */\n  allowInsecureConnection?: boolean;\n}\n\nclass PipelineRequestImpl implements PipelineRequest {\n  public url: string;\n  public method: HttpMethods;\n  public headers: HttpHeaders;\n  public timeout: number;\n  public withCredentials: boolean;\n  public body?: RequestBodyType;\n  public formData?: FormDataMap;\n  public streamResponseStatusCodes?: Set<number>;\n  public proxySettings?: ProxySettings;\n  public disableKeepAlive: boolean;\n  public abortSignal?: AbortSignalLike;\n  public requestId: string;\n  public tracingOptions?: OperationTracingOptions;\n  public allowInsecureConnection?: boolean;\n  public onUploadProgress?: (progress: TransferProgressEvent) => void;\n  public onDownloadProgress?: (progress: TransferProgressEvent) => void;\n\n  constructor(options: PipelineRequestOptions) {\n    this.url = options.url;\n    this.body = options.body;\n    this.headers = options.headers ?? createHttpHeaders();\n    this.method = options.method ?? \"GET\";\n    this.timeout = options.timeout ?? 0;\n    this.formData = options.formData;\n    this.disableKeepAlive = options.disableKeepAlive ?? false;\n    this.proxySettings = options.proxySettings;\n    this.streamResponseStatusCodes = options.streamResponseStatusCodes;\n    this.withCredentials = options.withCredentials ?? false;\n    this.abortSignal = options.abortSignal;\n    this.tracingOptions = options.tracingOptions;\n    this.onUploadProgress = options.onUploadProgress;\n    this.onDownloadProgress = options.onDownloadProgress;\n    this.requestId = options.requestId || generateUuid();\n    this.allowInsecureConnection = options.allowInsecureConnection ?? false;\n  }\n}\n\n/**\n * Creates a new pipeline request with the given options.\n * This method is to allow for the easy setting of default values and not required.\n * @param options - The options to create the request with.\n */\nexport function createPipelineRequest(options: PipelineRequestOptions): PipelineRequest {\n  return new PipelineRequestImpl(options);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AccessToken, GetTokenOptions, TokenCredential } from \"@azure/core-auth\";\nimport { delay } from \"./helpers\";\n\n/**\n * A function that gets a promise of an access token and allows providing\n * options.\n *\n * @param options - the options to pass to the underlying token provider\n */\nexport type AccessTokenGetter = (\n  scopes: string | string[],\n  options: GetTokenOptions\n) => Promise<AccessToken>;\n\nexport interface TokenCyclerOptions {\n  /**\n   * The window of time before token expiration during which the token will be\n   * considered unusable due to risk of the token expiring before sending the\n   * request.\n   *\n   * This will only become meaningful if the refresh fails for over\n   * (refreshWindow - forcedRefreshWindow) milliseconds.\n   */\n  forcedRefreshWindowInMs: number;\n  /**\n   * Interval in milliseconds to retry failed token refreshes.\n   */\n  retryIntervalInMs: number;\n  /**\n   * The window of time before token expiration during which\n   * we will attempt to refresh the token.\n   */\n  refreshWindowInMs: number;\n}\n\n// Default options for the cycler if none are provided\nexport const DEFAULT_CYCLER_OPTIONS: TokenCyclerOptions = {\n  forcedRefreshWindowInMs: 1000, // Force waiting for a refresh 1s before the token expires\n  retryIntervalInMs: 3000, // Allow refresh attempts every 3s\n  refreshWindowInMs: 1000 * 60 * 2 // Start refreshing 2m before expiry\n};\n\n/**\n * Converts an an unreliable access token getter (which may resolve with null)\n * into an AccessTokenGetter by retrying the unreliable getter in a regular\n * interval.\n *\n * @param getAccessToken - A function that produces a promise of an access token that may fail by returning null.\n * @param retryIntervalInMs - The time (in milliseconds) to wait between retry attempts.\n * @param refreshTimeout - The timestamp after which the refresh attempt will fail, throwing an exception.\n * @returns - A promise that, if it resolves, will resolve with an access token.\n */\nasync function beginRefresh(\n  getAccessToken: () => Promise<AccessToken | null>,\n  retryIntervalInMs: number,\n  refreshTimeout: number\n): Promise<AccessToken> {\n  // This wrapper handles exceptions gracefully as long as we haven't exceeded\n  // the timeout.\n  async function tryGetAccessToken(): Promise<AccessToken | null> {\n    if (Date.now() < refreshTimeout) {\n      try {\n        return await getAccessToken();\n      } catch {\n        return null;\n      }\n    } else {\n      const finalToken = await getAccessToken();\n\n      // Timeout is up, so throw if it's still null\n      if (finalToken === null) {\n        throw new Error(\"Failed to refresh access token.\");\n      }\n\n      return finalToken;\n    }\n  }\n\n  let token: AccessToken | null = await tryGetAccessToken();\n\n  while (token === null) {\n    await delay(retryIntervalInMs);\n\n    token = await tryGetAccessToken();\n  }\n\n  return token;\n}\n\n/**\n * Creates a token cycler from a credential, scopes, and optional settings.\n *\n * A token cycler represents a way to reliably retrieve a valid access token\n * from a TokenCredential. It will handle initializing the token, refreshing it\n * when it nears expiration, and synchronizes refresh attempts to avoid\n * concurrency hazards.\n *\n * @param credential - the underlying TokenCredential that provides the access\n * token\n * @param tokenCyclerOptions - optionally override default settings for the cycler\n *\n * @returns - a function that reliably produces a valid access token\n */\nexport function createTokenCycler(\n  credential: TokenCredential,\n  tokenCyclerOptions?: Partial<TokenCyclerOptions>\n): AccessTokenGetter {\n  let refreshWorker: Promise<AccessToken> | null = null;\n  let token: AccessToken | null = null;\n\n  const options = {\n    ...DEFAULT_CYCLER_OPTIONS,\n    ...tokenCyclerOptions\n  };\n\n  /**\n   * This little holder defines several predicates that we use to construct\n   * the rules of refreshing the token.\n   */\n  const cycler = {\n    /**\n     * Produces true if a refresh job is currently in progress.\n     */\n    get isRefreshing(): boolean {\n      return refreshWorker !== null;\n    },\n    /**\n     * Produces true if the cycler SHOULD refresh (we are within the refresh\n     * window and not already refreshing)\n     */\n    get shouldRefresh(): boolean {\n      return (\n        !cycler.isRefreshing &&\n        (token?.expiresOnTimestamp ?? 0) - options.refreshWindowInMs < Date.now()\n      );\n    },\n    /**\n     * Produces true if the cycler MUST refresh (null or nearly-expired\n     * token).\n     */\n    get mustRefresh(): boolean {\n      return (\n        token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now()\n      );\n    }\n  };\n\n  /**\n   * Starts a refresh job or returns the existing job if one is already\n   * running.\n   */\n  function refresh(\n    scopes: string | string[],\n    getTokenOptions: GetTokenOptions\n  ): Promise<AccessToken> {\n    if (!cycler.isRefreshing) {\n      // We bind `scopes` here to avoid passing it around a lot\n      const tryGetAccessToken = (): Promise<AccessToken | null> =>\n        credential.getToken(scopes, getTokenOptions);\n\n      // Take advantage of promise chaining to insert an assignment to `token`\n      // before the refresh can be considered done.\n      refreshWorker = beginRefresh(\n        tryGetAccessToken,\n        options.retryIntervalInMs,\n        // If we don't have a token, then we should timeout immediately\n        token?.expiresOnTimestamp ?? Date.now()\n      )\n        .then((_token) => {\n          refreshWorker = null;\n          token = _token;\n          return token;\n        })\n        .catch((reason) => {\n          // We also should reset the refresher if we enter a failed state.  All\n          // existing awaiters will throw, but subsequent requests will start a\n          // new retry chain.\n          refreshWorker = null;\n          token = null;\n          throw reason;\n        });\n    }\n\n    return refreshWorker as Promise<AccessToken>;\n  }\n\n  return async (scopes: string | string[], tokenOptions: GetTokenOptions): Promise<AccessToken> => {\n    //\n    // Simple rules:\n    // - If we MUST refresh, then return the refresh task, blocking\n    //   the pipeline until a token is available.\n    // - If we SHOULD refresh, then run refresh but don't return it\n    //   (we can still use the cached token).\n    // - Return the token, since it's fine if we didn't return in\n    //   step 1.\n    //\n\n    if (cycler.mustRefresh) return refresh(scopes, tokenOptions);\n\n    if (cycler.shouldRefresh) {\n      refresh(scopes, tokenOptions);\n    }\n\n    return token as AccessToken;\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { TokenCredential, GetTokenOptions, AccessToken } from \"@azure/core-auth\";\nimport { PipelineResponse, PipelineRequest, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\nimport { createTokenCycler } from \"../util/tokenCycler\";\n\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n\n/**\n * Options sent to the authorizeRequest callback\n */\nexport interface AuthorizeRequestOptions {\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string[];\n  /**\n   * Function that retrieves either a cached access token or a new access token.\n   */\n  getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;\n  /**\n   * Request that the policy is trying to fulfill.\n   */\n  request: PipelineRequest;\n}\n\n/**\n * Options sent to the authorizeRequestOnChallenge callback\n */\nexport interface AuthorizeRequestOnChallengeOptions {\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string[];\n  /**\n   * Function that retrieves either a cached access token or a new access token.\n   */\n  getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;\n  /**\n   * Request that the policy is trying to fulfill.\n   */\n  request: PipelineRequest;\n  /**\n   * Response containing the challenge.\n   */\n  response: PipelineResponse;\n}\n\n/**\n * Options to override the processing of [Continuous Access Evaluation](https://docs.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.\n */\nexport interface ChallengeCallbacks {\n  /**\n   * Allows for the authorization of the main request of this policy before it's sent.\n   */\n  authorizeRequest?(options: AuthorizeRequestOptions): Promise<void>;\n  /**\n   * Allows to handle authentication challenges and to re-authorize the request.\n   * The response containing the challenge is `options.response`.\n   * If this method returns true, the underlying request will be sent once again.\n   * The request may be modified before being sent.\n   */\n  authorizeRequestOnChallenge?(options: AuthorizeRequestOnChallengeOptions): Promise<boolean>;\n}\n\n/**\n * Options to configure the bearerTokenAuthenticationPolicy\n */\nexport interface BearerTokenAuthenticationPolicyOptions {\n  /**\n   * The TokenCredential implementation that can supply the bearer token.\n   */\n  credential?: TokenCredential;\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string | string[];\n  /**\n   * Allows for the processing of [Continuous Access Evaluation](https://docs.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.\n   * If provided, it must contain at least the `authorizeRequestOnChallenge` method.\n   * If provided, after a request is sent, if it has a challenge, it can be processed to re-send the original request with the relevant challenge information.\n   */\n  challengeCallbacks?: ChallengeCallbacks;\n}\n\n/**\n * Default authorize request handler\n */\nasync function defaultAuthorizeRequest(options: AuthorizeRequestOptions): Promise<void> {\n  const { scopes, getAccessToken, request } = options;\n  const getTokenOptions: GetTokenOptions = {\n    abortSignal: request.abortSignal,\n    tracingOptions: request.tracingOptions\n  };\n  const accessToken = await getAccessToken(scopes, getTokenOptions);\n\n  if (accessToken) {\n    options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n  }\n}\n\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response: PipelineResponse): string | undefined {\n  const challenge = response.headers.get(\"WWW-Authenticate\");\n  if (response.status === 401 && challenge) {\n    return challenge;\n  }\n  return;\n}\n\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nexport function bearerTokenAuthenticationPolicy(\n  options: BearerTokenAuthenticationPolicyOptions\n): PipelinePolicy {\n  const { credential, scopes, challengeCallbacks } = options;\n  const callbacks = {\n    authorizeRequest: challengeCallbacks?.authorizeRequest ?? defaultAuthorizeRequest,\n    authorizeRequestOnChallenge: challengeCallbacks?.authorizeRequestOnChallenge,\n    // keep all other properties\n    ...challengeCallbacks\n  };\n\n  // This function encapsulates the entire process of reliably retrieving the token\n  // The options are left out of the public API until there's demand to configure this.\n  // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n  // in order to pass through the `options` object.\n  const getAccessToken = credential\n    ? createTokenCycler(credential /* , options */)\n    : () => Promise.resolve(null);\n\n  return {\n    name: bearerTokenAuthenticationPolicyName,\n    /**\n     * If there's no challenge parameter:\n     * - It will try to retrieve the token using the cache, or the credential's getToken.\n     * - Then it will try the next policy with or without the retrieved token.\n     *\n     * It uses the challenge parameters to:\n     * - Skip a first attempt to get the token from the credential if there's no cached token,\n     *   since it expects the token to be retrievable only after the challenge.\n     * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n     * - Send an initial request to receive the challenge if it fails.\n     * - Process a challenge if the response contains it.\n     * - Retrieve a token with the challenge information, then re-send the request.\n     */\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.url.toLowerCase().startsWith(\"https://\")) {\n        throw new Error(\n          \"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\"\n        );\n      }\n\n      await callbacks.authorizeRequest({\n        scopes: Array.isArray(scopes) ? scopes : [scopes],\n        request,\n        getAccessToken\n      });\n\n      let response: PipelineResponse;\n      let error: Error | undefined;\n      try {\n        response = await next(request);\n      } catch (err) {\n        error = err;\n        response = err.response;\n      }\n\n      if (\n        callbacks.authorizeRequestOnChallenge &&\n        response?.status === 401 &&\n        getChallenge(response)\n      ) {\n        // processes challenge\n        const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({\n          scopes: Array.isArray(scopes) ? scopes : [scopes],\n          request,\n          response,\n          getAccessToken\n        });\n\n        if (shouldSendRequest) {\n          return next(request);\n        }\n      }\n\n      if (error) {\n        throw error;\n      } else {\n        return response;\n      }\n    }\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PipelineResponse, PipelineRequest, SendRequest } from \"../interfaces\";\nimport { PipelinePolicy } from \"../pipeline\";\n\n/**\n * The programmatic identifier of the ndJsonPolicy.\n */\nexport const ndJsonPolicyName = \"ndJsonPolicy\";\n\n/**\n * ndJsonPolicy is a policy used to control keep alive settings for every request.\n */\nexport function ndJsonPolicy(): PipelinePolicy {\n  return {\n    name: ndJsonPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      // There currently isn't a good way to bypass the serializer\n      if (typeof request.body === \"string\" && request.body.startsWith(\"[\")) {\n        const body = JSON.parse(request.body);\n        if (Array.isArray(body)) {\n          request.body = body.map((item) => JSON.stringify(item) + \"\\n\").join(\"\");\n        }\n      }\n      return next(request);\n    }\n  };\n}\n"],"names":["createClientLogger","url","URL","logger","coreLogger","os.arch","os.type","os.release","inspect","createSpanFunction","SpanKind","getTraceParentHeader","isSpanContextValid","SpanStatusCode","DEFAULT_CLIENT_RETRY_COUNT","DEFAULT_CLIENT_RETRY_INTERVAL","DEFAULT_CLIENT_MAX_RETRY_INTERVAL","HttpProxyAgent","HttpsProxyAgent","Transform","abortController","AbortController","AbortError","http.request","https.request","http.Agent","https.Agent","http.globalAgent","https.globalAgent","zlib.createGunzip","zlib.createInflate","uuidv4"],"mappings":"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"}